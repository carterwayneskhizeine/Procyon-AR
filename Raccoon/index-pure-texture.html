<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <script type="module">
      import * as THREE from 'three';
      import { MindARThree } from '../src/face-target/three.js';
      import * as faceapi from 'face-api.js';
      
      // 🎯 面部识别相关变量 (face-api.js)
      let trackingStarted = false;
      let faceDetectorOptions = null; // TinyFaceDetector 配置
      let currentLandmarks = null;    // 平滑后的关键点
      let facePointsCanvas = null;
      let facePointsCtx = null;
      
      // 🎯 1€ 滤波器实现 - 专为低延迟交互设计
      class OneEuroFilter {
        constructor(freq, minCutoff = 1.0, beta = 0.0, dCutoff = 1.0) {
          this.freq = freq;
          this.minCutoff = minCutoff;
          this.beta = beta;
          this.dCutoff = dCutoff;
          this.x = null;
          this.dx = null;
          this._alpha = (dt, cutoff) => 1.0 / (1.0 + (1.0 / (2.0 * Math.PI * cutoff * dt)));
        }
        
        filter(x, dt = 1.0 / 30.0) {
          if (this.x === null) {
            this.x = x;
            this.dx = 0;
            return x;
          }
          
          const dx = (x - this.x) / dt;
          const edx = this._alpha(dt, this.dCutoff) * dx + (1 - this._alpha(dt, this.dCutoff)) * this.dx;
          
          const cutoff = this.minCutoff + this.beta * Math.abs(edx);
          const ex = this._alpha(dt, cutoff) * x + (1 - this._alpha(dt, cutoff)) * this.x;
          
          this.x = ex;
          this.dx = edx;
          return ex;
        }
      }
      
      // 🎯 为每个关键点创建2D滤波器
      let landmarkFilters = null;
      const initLandmarkFilters = (numPoints = 68) => {
        landmarkFilters = Array.from({ length: numPoints }, () => ({
          x: new OneEuroFilter(30, 1.2, 0.04, 1.0), // freq=30fps, minCutoff=1.2(更稳), beta=0.04(响应速度)
          y: new OneEuroFilter(30, 1.2, 0.04, 1.0)
        }));
      };
      
      // 🎯 优化检测策略：不是每帧都检测
      let detectionCounter = 0;
      let lastDetectionTime = 0;
      let detectionInterval = 2; // 每2帧检测一次，减少计算负担
      let lastValidLandmarks = null;
      
      // 🎯 性能监控变量
      let lastFrameTime = performance.now();
      let frameCount = 0;
      let avgFPS = 30;
      
      // 🎨 共享调色板配置管理
      const ColorPaletteManager = {
        // 默认配置
        defaultConfig: {
          customColor: { r: 0.9, g: 0.7, b: 0.6 },
          colorIntensity: 0.8,
          colorMode: 'multiply',
          useAutoColor: true,
          redValue: 230,
          greenValue: 179,
          blueValue: 153,
          materialOpacity: 0.7  // 默认70%透明度
        },
        
        // 从localStorage加载配置
        loadConfig() {
          try {
            const savedConfig = localStorage.getItem('raccoon-color-palette');
            if (savedConfig) {
              const config = JSON.parse(savedConfig);
              console.log('✅ 已加载保存的调色板配置');
              return { ...this.defaultConfig, ...config };
            }
          } catch (error) {
            console.warn('⚠️ 加载调色板配置失败，使用默认配置:', error);
          }
          return this.defaultConfig;
        },
        
        // 保存配置到localStorage
        saveConfig(config) {
          try {
            localStorage.setItem('raccoon-color-palette', JSON.stringify(config));
            console.log('💾 调色板配置已保存');
          } catch (error) {
            console.warn('⚠️ 保存调色板配置失败:', error);
          }
        },
        
        // 获取当前配置
        getCurrentConfig() {
          return {
            customColor: {
              r: customColor.r,
              g: customColor.g,
              b: customColor.b
            },
            colorIntensity,
            colorMode,
            useAutoColor,
            redValue: Math.round(customColor.r * 255),
            greenValue: Math.round(customColor.g * 255),
            blueValue: Math.round(customColor.b * 255),
            materialOpacity
          };
        }
      };
      
      // 加载保存的配置
      const savedConfig = ColorPaletteManager.loadConfig();
      
      // 🎨 颜色控制设置 - 使用保存的配置初始化
      let customColor = new THREE.Color(savedConfig.customColor.r, savedConfig.customColor.g, savedConfig.customColor.b);
      let colorIntensity = savedConfig.colorIntensity;
      let colorMode = savedConfig.colorMode;
      let useAutoColor = savedConfig.useAutoColor;
      
      // 🔍 透明度控制设置
      let materialOpacity = savedConfig.materialOpacity || 0.7; // 默认70%透明度，让人脸可见
      
      // 颜色采样相关变量
      let colorCanvas = null;
      let colorCtx = null;
      let lastFaceColor = new THREE.Color(0.8, 0.6, 0.5);
      let colorUpdateCounter = 0;
      let originalMaterial = null; // 保存原始材质
      let unlitMaterial = null; // 🔍 全局材质引用，用于透明度控制
      
      // 🎬 画面合成相关变量
      let compositeCanvas = null;
      let compositeCtx = null;
      let websocketServer = null;
      let isCompositeEnabled = true;
      
             // 🎯 初始化面部识别系统 (face-api.js)
       const initFaceTracking = async () => {
         console.log('🎯 初始化面部识别系统 (face-api.js)...');

         try {
           // 🎯 优先尝试本地模型，失败时使用 CDN
           let modelLoaded = false;
           
           try {
             console.log('📦 尝试加载本地模型...');
             await Promise.all([
               faceapi.nets.tinyFaceDetector.loadFromUri('./models'),
               faceapi.nets.faceLandmark68TinyNet.loadFromUri('./models')
             ]);
             modelLoaded = true;
             console.log('✅ 本地模型加载成功');
           } catch (localError) {
             console.warn('⚠️ 本地模型加载失败，尝试CDN模型:', localError.message);
             
             const MODEL_URL = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights';
             await Promise.all([
               faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
               faceapi.nets.faceLandmark68TinyNet.loadFromUri(MODEL_URL)
             ]);
             modelLoaded = true;
             console.log('✅ CDN模型加载成功');
           }
           
           faceDetectorOptions = new faceapi.TinyFaceDetectorOptions({ inputSize: 256, scoreThreshold: 0.5 });
           console.log('✅ face-api.js 模型加载完成');
         } catch (error) {
           console.error('❌ face-api.js 模型加载失败:', error);
           return false;
         }

         // 创建面部点位绘制画布
         facePointsCanvas = document.createElement('canvas');
         facePointsCanvas.id = 'face-points-overlay';
         facePointsCanvas.style.position = 'absolute';
         facePointsCanvas.style.top = '0px';
         facePointsCanvas.style.left = '0px';
         facePointsCanvas.style.pointerEvents = 'none';
         facePointsCanvas.style.zIndex = '1000';
         facePointsCtx = facePointsCanvas.getContext('2d');

         // 添加到容器
         const container = document.querySelector('#container');
         if (container) {
           container.appendChild(facePointsCanvas);
         }

         return true;
       };
      
      // 🎯 开始面部跟踪
      const startFaceTracking = (videoElement) => {
        if (!videoElement || !faceDetectorOptions) {
          console.warn('⚠️ face-api.js 未就绪');
          return false;
        }
        trackingStarted = true;
        console.log('✅ 面部检测已启动');
        return true;
      };
      
             // 🎯 绘制面部点位（带缩放和偏移）
       const drawFacePoints = () => {
         if (!facePointsCtx || !currentLandmarks) return;

         // 清空画布
         facePointsCtx.clearRect(0, 0, facePointsCanvas.width, facePointsCanvas.height);

         facePointsCtx.save();
         // 🎯 应用变换：偏移 + 缩放 + 水平翻转
         facePointsCtx.translate(videoOffsetX, videoOffsetY);
         facePointsCtx.scale(videoScaleX, videoScaleY);
         facePointsCtx.scale(-1, 1); // 水平翻转匹配视频
         facePointsCtx.translate(-facePointsCanvas.width / videoScaleX, 0);

         // 绘制关键点
         facePointsCtx.fillStyle = 'rgba(0,255,0,0.8)';
         currentLandmarks.forEach(pt => {
           facePointsCtx.beginPath();
           facePointsCtx.arc(pt.x, pt.y, 2, 0, Math.PI * 2);
           facePointsCtx.fill();
         });

         facePointsCtx.restore();
       };
      
      
      
             // 🎯 调整面部点位画布尺寸和缩放比例
       let videoScaleX = 1;
       let videoScaleY = 1;
       let videoOffsetX = 0;
       let videoOffsetY = 0;
       
       const adjustFacePointsCanvas = (videoElement) => {
         if (!facePointsCanvas || !videoElement) return;
         
         const container = document.querySelector('#container');
         
         if (container && videoElement.videoWidth && videoElement.videoHeight) {
           // 设置画布尺寸与容器一致
           facePointsCanvas.width = container.clientWidth;
           facePointsCanvas.height = container.clientHeight;
           facePointsCanvas.style.width = container.clientWidth + 'px';
           facePointsCanvas.style.height = container.clientHeight + 'px';
           
           // 🎯 计算视频缩放比例（仿照 MindAR 的缩放逻辑）
           const videoRatio = videoElement.videoWidth / videoElement.videoHeight;
           const containerRatio = container.clientWidth / container.clientHeight;
           
           let displayWidth, displayHeight;
           if (videoRatio > containerRatio) {
             displayHeight = container.clientHeight;
             displayWidth = displayHeight * videoRatio;
           } else {
             displayWidth = container.clientWidth;
             displayHeight = displayWidth / videoRatio;
           }
           
           // 计算缩放比例和偏移量
           videoScaleX = displayWidth / videoElement.videoWidth;
           videoScaleY = displayHeight / videoElement.videoHeight;
           videoOffsetX = (container.clientWidth - displayWidth) / 2;
           videoOffsetY = (container.clientHeight - displayHeight) / 2;
           
           console.log('🎯 画布尺寸和缩放比例调整:', {
             canvasSize: `${facePointsCanvas.width}x${facePointsCanvas.height}`,
             videoOriginalSize: `${videoElement.videoWidth}x${videoElement.videoHeight}`,
             videoDisplaySize: `${displayWidth}x${displayHeight}`,
             scaleX: videoScaleX,
             scaleY: videoScaleY,
             offsetX: videoOffsetX,
             offsetY: videoOffsetY
           });
         }
       };
      
      // 创建颜色控制面板
      const createColorControlPanel = () => {
        const controlPanel = document.createElement('div');
        controlPanel.id = 'color-control-panel';
        controlPanel.innerHTML = `
          <div style="position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.85); color: white; padding: 15px; border-radius: 8px; font-family: Arial, sans-serif; font-size: 12px; z-index: 1001; width: 250px;">
            <h3 style="margin: 0 0 10px 0; color: #FFD700;">🎨 共享调色板 + 🎯 面部识别</h3>
            
                         <div style="margin-bottom: 10px; padding: 8px; background: #333; border-radius: 4px;">
               <div style="color: #00FF00; font-weight: bold; margin-bottom: 5px;">🎯 面部识别状态</div>
               <div id="faceTrackingStatus" style="color: #888;">初始化中...</div>
               <div style="font-size: 10px; color: #666; margin-top: 3px;">face-api.js 面部检测</div>
               <div id="performanceInfo" style="font-size: 9px; color: #999; margin-top: 3px;">
                 检测间隔: -- | 滤波状态: --
               </div>
             </div>
            
            <div style="margin-bottom: 10px;">
              <label style="display: block; margin-bottom: 5px;">颜色模式:</label>
              <select id="colorModeSelect" style="width: 100%; padding: 3px; background: #333; color: white; border: 1px solid #555;">
                <option value="multiply">乘法混合 (推荐)</option>
                <option value="overlay">叠加混合</option>
                <option value="lerp">线性插值</option>
              </select>
            </div>
            
            <div style="margin-bottom: 10px;">
              <label style="display: block; margin-bottom: 5px;">
                <input type="checkbox" id="useAutoColorCheck" ${useAutoColor ? 'checked' : ''}> 自动肤色采样
              </label>
            </div>
            
            <div id="manualColorControls" style="display: ${useAutoColor ? 'none' : 'block'};">
              <div style="margin-bottom: 8px;">
                <label style="display: block; margin-bottom: 3px;">自定义颜色:</label>
                <input type="color" id="customColorPicker" style="width: 100%; height: 30px; border: none; border-radius: 4px;">
              </div>
            </div>
            
            <div style="margin-bottom: 8px;">
              <label style="display: block; margin-bottom: 3px;">强度: <span id="intensityValue">${Math.round(colorIntensity * 100)}%</span></label>
              <input type="range" id="intensitySlider" min="0" max="100" value="${Math.round(colorIntensity * 100)}" style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 8px;">
              <label style="display: block; margin-bottom: 3px;">透明度: <span id="opacityValue">${Math.round(materialOpacity * 100)}%</span></label>
              <input type="range" id="opacitySlider" min="0" max="100" value="${Math.round(materialOpacity * 100)}" style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 8px;">
              <label style="display: block; margin-bottom: 3px;">红色: <span id="redValue">${savedConfig.redValue}</span></label>
              <input type="range" id="redSlider" min="0" max="255" value="${savedConfig.redValue}" style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 8px;">
              <label style="display: block; margin-bottom: 3px;">绿色: <span id="greenValue">${savedConfig.greenValue}</span></label>
              <input type="range" id="greenSlider" min="0" max="255" value="${savedConfig.greenValue}" style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 10px;">
              <label style="display: block; margin-bottom: 3px;">蓝色: <span id="blueValue">${savedConfig.blueValue}</span></label>
              <input type="range" id="blueSlider" min="0" max="255" value="${savedConfig.blueValue}" style="width: 100%;">
            </div>
            
            <div style="margin-top: 10px; padding: 8px; background: #444; border-radius: 4px;">
              <div style="color: #FFD700; font-weight: bold; margin-bottom: 5px;">🎛️ 抖动控制 (1€滤波)</div>
              
              <div style="margin-bottom: 6px;">
                <label style="display: block; margin-bottom: 2px; font-size: 10px;">平滑强度: <span id="minCutoffValue">1.2</span></label>
                <input type="range" id="minCutoffSlider" min="0.5" max="3.0" step="0.1" value="1.2" style="width: 100%;">
              </div>
              
              <div style="margin-bottom: 6px;">
                <label style="display: block; margin-bottom: 2px; font-size: 10px;">响应速度: <span id="betaValue">0.04</span></label>
                <input type="range" id="betaSlider" min="0.01" max="0.1" step="0.01" value="0.04" style="width: 100%;">
              </div>
              
              <div style="margin-bottom: 6px;">
                <label style="display: block; margin-bottom: 2px; font-size: 10px;">检测频率: <span id="detectionFreqValue">自适应</span></label>
                <select id="detectionFreqSelect" style="width: 100%; padding: 2px; background: #333; color: white; border: 1px solid #555; font-size: 10px;">
                  <option value="adaptive">自适应 (推荐)</option>
                  <option value="1">每帧检测 (高精度)</option>
                  <option value="2">每2帧检测</option>
                  <option value="3">每3帧检测 (省性能)</option>
                </select>
              </div>
            </div>
            
            <div style="background: #333; padding: 8px; border-radius: 4px; text-align: center;">
              <div id="colorPreview" style="width: 100%; height: 20px; border-radius: 3px; margin-bottom: 5px;"></div>
              <span id="colorHex"></span>
            </div>
            
            <div style="margin-top: 10px; text-align: center;">
              <button id="resetColorBtn" style="background: #555; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-right: 5px;">重置</button>
              <button id="warmToneBtn" style="background: #8B4513; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">暖色调</button>
            </div>
            
            <div style="margin-top: 8px; font-size: 9px; color: #888; text-align: center;">
              配置自动同步到Mesh版本<br/>
              🎭 透明度遮罩 + 半透明 | ShaderMaterial<br/>
              🎯 face-api.js + 1€滤波 + 智能检测频率<br/>
              🎛️ 实时调参 | 🚀 低延迟优化
            </div>
          </div>
        `;
        document.body.appendChild(controlPanel);
        
        setupColorControlEvents();
      };
      
      // 设置颜色控制事件
      const setupColorControlEvents = () => {
        const colorModeSelect = document.getElementById('colorModeSelect');
        const useAutoColorCheck = document.getElementById('useAutoColorCheck');
        const manualColorControls = document.getElementById('manualColorControls');
        const customColorPicker = document.getElementById('customColorPicker');
        const intensitySlider = document.getElementById('intensitySlider');
        const opacitySlider = document.getElementById('opacitySlider');
        const redSlider = document.getElementById('redSlider');
        const greenSlider = document.getElementById('greenSlider');
        const blueSlider = document.getElementById('blueSlider');
        
        // 设置初始值
        colorModeSelect.value = colorMode;
        
        // 自动保存配置的函数
        const saveCurrentConfig = () => {
          const config = ColorPaletteManager.getCurrentConfig();
          ColorPaletteManager.saveConfig(config);
        };
        
        // 颜色模式切换
        colorModeSelect.addEventListener('change', (e) => {
          colorMode = e.target.value;
          saveCurrentConfig();
        });
        
        // 自动/手动颜色切换
        useAutoColorCheck.addEventListener('change', (e) => {
          useAutoColor = e.target.checked;
          manualColorControls.style.display = useAutoColor ? 'none' : 'block';
          saveCurrentConfig();
        });
        
        // 更新颜色的函数
        const updateColor = () => {
          const r = parseInt(redSlider.value);
          const g = parseInt(greenSlider.value);
          const b = parseInt(blueSlider.value);
          
          customColor.setRGB(r / 255, g / 255, b / 255);
          colorIntensity = parseInt(intensitySlider.value) / 100;
          materialOpacity = parseInt(opacitySlider.value) / 100;
          
          // 🔍 实时更新材质透明度 (Shader材质)
          if (unlitMaterial && unlitMaterial.uniforms) {
            unlitMaterial.uniforms.opacity.value = materialOpacity;
            unlitMaterial.needsUpdate = true;
          }
          
          // 更新显示
          document.getElementById('redValue').textContent = r;
          document.getElementById('greenValue').textContent = g;
          document.getElementById('blueValue').textContent = b;
          document.getElementById('intensityValue').textContent = Math.round(colorIntensity * 100) + '%';
          document.getElementById('opacityValue').textContent = Math.round(materialOpacity * 100) + '%';
          
          const colorPreview = document.getElementById('colorPreview');
          const colorHex = document.getElementById('colorHex');
          const hexColor = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
          
          colorPreview.style.background = `rgba(${r}, ${g}, ${b}, ${materialOpacity})`;
          colorHex.textContent = hexColor;
          customColorPicker.value = hexColor;
          
          // 自动保存配置
          saveCurrentConfig();
        };
        
        // 绑定滑块事件
        intensitySlider.addEventListener('input', updateColor);
        opacitySlider.addEventListener('input', updateColor);
        redSlider.addEventListener('input', updateColor);
        greenSlider.addEventListener('input', updateColor);
        blueSlider.addEventListener('input', updateColor);
        
        // 颜色选择器事件
        customColorPicker.addEventListener('change', (e) => {
          const hex = e.target.value;
          const r = parseInt(hex.substr(1, 2), 16);
          const g = parseInt(hex.substr(3, 2), 16);
          const b = parseInt(hex.substr(5, 2), 16);
          
          redSlider.value = r;
          greenSlider.value = g;
          blueSlider.value = b;
          updateColor();
        });
        
        // 预设颜色按钮事件
        const resetColorBtn = document.getElementById('resetColorBtn');
        const warmToneBtn = document.getElementById('warmToneBtn');
        
        resetColorBtn.addEventListener('click', () => {
          redSlider.value = 230;
          greenSlider.value = 179;
          blueSlider.value = 153;
          intensitySlider.value = 80;
          opacitySlider.value = 70;  // 重置透明度为70%
          updateColor();
        });
        
        warmToneBtn.addEventListener('click', () => {
          redSlider.value = 210;
          greenSlider.value = 150;
          blueSlider.value = 120;
          intensitySlider.value = 75;
          opacitySlider.value = 70;  // 暖色调也设置70%透明度
          updateColor();
        });
        
        // 初始化显示
        updateColor();
        
        // 🎯 滤波器参数控制
        const minCutoffSlider = document.getElementById('minCutoffSlider');
        const betaSlider = document.getElementById('betaSlider');
        const detectionFreqSelect = document.getElementById('detectionFreqSelect');
        
        // 滤波器参数更新
        const updateFilterParams = () => {
          const minCutoff = parseFloat(minCutoffSlider.value);
          const beta = parseFloat(betaSlider.value);
          
          // 更新显示
          document.getElementById('minCutoffValue').textContent = minCutoff;
          document.getElementById('betaValue').textContent = beta;
          
          // 重新初始化滤波器
          if (landmarkFilters) {
            landmarkFilters.forEach(filter => {
              filter.x.minCutoff = minCutoff;
              filter.x.beta = beta;
              filter.y.minCutoff = minCutoff;
              filter.y.beta = beta;
            });
          }
        };
        
        minCutoffSlider.addEventListener('input', updateFilterParams);
        betaSlider.addEventListener('input', updateFilterParams);
        
        // 检测频率控制
        detectionFreqSelect.addEventListener('change', (e) => {
          const value = e.target.value;
          if (value === 'adaptive') {
            document.getElementById('detectionFreqValue').textContent = '自适应';
            // 恢复自适应模式（在渲染循环中动态调整）
          } else {
            const freq = parseInt(value);
            detectionInterval = freq;
            document.getElementById('detectionFreqValue').textContent = `每${freq}帧`;
          }
        });
      };
      
      // 🎯 更新面部识别状态显示
      const updateFaceTrackingStatus = (status) => {
        const statusElement = document.getElementById('faceTrackingStatus');
        if (statusElement) {
          statusElement.textContent = status;
        }
      };
      
      // 🎯 更新性能信息显示
      const updatePerformanceInfo = (interval, filterActive, fps) => {
        const perfElement = document.getElementById('performanceInfo');
        if (perfElement) {
          perfElement.textContent = `检测间隔: ${interval}帧 | 滤波: ${filterActive ? '✅' : '❌'} | 估计FPS: ${Math.round(fps)}`;
        }
      };
      
      // 初始化颜色采样Canvas
      const initColorSampling = () => {
        colorCanvas = document.createElement('canvas');
        colorCanvas.width = 64;
        colorCanvas.height = 64;
        colorCtx = colorCanvas.getContext('2d');
      };
      
      // 从视频中采样人脸颜色
      const sampleFaceColor = (video) => {
        if (!colorCtx) return lastFaceColor;
        
        try {
          colorUpdateCounter++;
          if (colorUpdateCounter % 10 !== 0) return lastFaceColor;
          
          colorCtx.drawImage(video, 0, 0, colorCanvas.width, colorCanvas.height);
          
          const centerX = Math.floor(colorCanvas.width * 0.5);
          const centerY = Math.floor(colorCanvas.height * 0.4);
          const sampleSize = 20;
          
          let r = 0, g = 0, b = 0, count = 0;
          
          for (let x = centerX - sampleSize; x < centerX + sampleSize; x++) {
            for (let y = centerY - sampleSize; y < centerY + sampleSize; y++) {
              if (x >= 0 && x < colorCanvas.width && y >= 0 && y < colorCanvas.height) {
                const imageData = colorCtx.getImageData(x, y, 1, 1);
                const [pr, pg, pb] = imageData.data;
                
                if (pr > 30 && pr < 240 && pg > 30 && pg < 240 && pb > 30 && pb < 240) {
                  r += pr;
                  g += pg;
                  b += pb;
                  count++;
                }
              }
            }
          }
          
          if (count > 0) {
            r /= count;
            g /= count;
            b /= count;
            
            const newColor = new THREE.Color(r / 255, g / 255, b / 255);
            lastFaceColor.lerp(newColor, 0.1);
          }
          
        } catch (error) {
          console.warn('颜色采样失败:', error);
        }
        
        return lastFaceColor;
      };
      
      // 应用颜色到FaceMesh (Shader材质版本)
      const applyColorToFaceMesh = (faceMesh, faceColor, intensity, mode) => {
        if (!faceMesh || !faceMesh.material || !originalMaterial || !faceMesh.material.uniforms) return;
        
        let blendedColor = new THREE.Color();
        
        if (mode === 'multiply') {
          blendedColor.copy(faceColor).multiply(originalMaterial.color);
        } else if (mode === 'overlay') {
          const base = originalMaterial.color;
          const overlay = faceColor;
          blendedColor.setRGB(
            base.r < 0.5 ? 2 * base.r * overlay.r : 1 - 2 * (1 - base.r) * (1 - overlay.r),
            base.g < 0.5 ? 2 * base.g * overlay.g : 1 - 2 * (1 - base.g) * (1 - overlay.g),
            base.b < 0.5 ? 2 * base.b * overlay.b : 1 - 2 * (1 - base.b) * (1 - overlay.b)
          );
        } else {
          blendedColor.copy(originalMaterial.color).lerp(faceColor, intensity);
        }
        
        if (mode !== 'lerp') {
          blendedColor.lerp(originalMaterial.color, 1 - intensity);
        }
        
        // 🎨 更新Shader材质的颜色uniform
        faceMesh.material.uniforms.color.value.copy(blendedColor);
        faceMesh.material.needsUpdate = true;
      };
      
      // 🎬 画面合成系统初始化
      const initCompositeSystem = () => {
        console.log('🎬 初始化画面合成系统...');
        
        // 创建合成画布
        compositeCanvas = document.createElement('canvas');
        compositeCanvas.width = 640;
        compositeCanvas.height = 480;
        compositeCtx = compositeCanvas.getContext('2d');
        
        // 初始化WebSocket服务器
        initWebSocketServer();
        
        console.log('✅ 画面合成系统初始化完成');
      };
      
      // 🌐 初始化WebSocket服务器
      const initWebSocketServer = () => {
        try {
          // 尝试连接到WebSocket服务器
          websocketServer = new WebSocket('ws://localhost:3002?type=sender');
          
          websocketServer.onopen = () => {
            console.log('✅ WebSocket服务器连接成功');
            isCompositeEnabled = true;
          };
          
          websocketServer.onclose = () => {
            console.log('❌ WebSocket服务器连接断开');
            isCompositeEnabled = false;
            
            // 5秒后尝试重连
            setTimeout(() => {
              if (!isCompositeEnabled) {
                initWebSocketServer();
              }
            }, 5000);
          };
          
          websocketServer.onerror = (error) => {
            console.warn('⚠️ WebSocket连接失败，将使用HTTP API备选方案:', error);
            isCompositeEnabled = false;
          };
          
        } catch (error) {
          console.warn('⚠️ WebSocket初始化失败，将使用HTTP API备选方案:', error);
          isCompositeEnabled = false;
        }
      };
      
      // 🎬 合成两层画面为单层像素画面
      const createCompositeFrame = (videoElement, threeRenderer, scene, camera) => {
        if (!compositeCanvas || !compositeCtx || !videoElement) return null;
        
        try {
          // 确保画布尺寸与视频匹配
          if (compositeCanvas.width !== videoElement.videoWidth || 
              compositeCanvas.height !== videoElement.videoHeight) {
            compositeCanvas.width = videoElement.videoWidth || 640;
            compositeCanvas.height = videoElement.videoHeight || 480;
          }
          
          // 清空画布
          compositeCtx.clearRect(0, 0, compositeCanvas.width, compositeCanvas.height);
          
          // 第一层：绘制原始视频画面（不翻转，保持原始方向）
          compositeCtx.drawImage(videoElement, 0, 0, compositeCanvas.width, compositeCanvas.height);
          
          // 第二层：获取Three.js渲染结果
          const threeCanvas = threeRenderer.domElement;
          if (threeCanvas) {
            // 设置混合模式为正常模式，确保真实像素合成
            compositeCtx.globalCompositeOperation = 'source-over';
            
            // 绘制Three.js渲染的面部网格（水平翻转以匹配视频）
            compositeCtx.save();
            compositeCtx.scale(-1, 1); // 水平翻转
            compositeCtx.translate(-compositeCanvas.width, 0);
            compositeCtx.drawImage(threeCanvas, 0, 0, compositeCanvas.width, compositeCanvas.height);
            compositeCtx.restore();
          }
          
          // 重置混合模式
          compositeCtx.globalCompositeOperation = 'source-over';
          
          return compositeCanvas;
          
        } catch (error) {
          console.error('❌ 画面合成失败:', error);
          return null;
        }
      };
      
      // 🚀 发送合成画面
      const sendCompositeFrame = (compositeCanvas) => {
        if (!compositeCanvas || !isCompositeEnabled) return;
        
        try {
          // 转换为Blob数据
          compositeCanvas.toBlob((blob) => {
            if (websocketServer && websocketServer.readyState === WebSocket.OPEN) {
              // 通过WebSocket发送
              websocketServer.send(blob);
            } else {
              // 备选方案：通过HTTP API发送
              sendCompositeFrameHTTP(blob);
            }
          }, 'image/jpeg', 0.85); // 使用JPEG格式，85%质量
          
        } catch (error) {
          console.error('❌ 发送合成画面失败:', error);
        }
      };
      
      // 📡 HTTP API备选方案
      const sendCompositeFrameHTTP = async (blob) => {
        try {
          const formData = new FormData();
          formData.append('composite-frame', blob, 'composite.jpg');
          
          await fetch('http://localhost:3001/api/composite-frame', {
            method: 'POST',
            body: formData
          });
          
        } catch (error) {
          console.warn('⚠️ HTTP发送合成画面失败:', error);
        }
      };
      
      // 创建控制面板
      createColorControlPanel();
      
      // 🎬 初始化画面合成系统
      initCompositeSystem();
      
      // 🎯 初始化面部识别系统 (异步)
      let faceTrackingInitialized = false;
      
      const mindarThree = new MindARThree({
        container: document.querySelector("#container"),
      });
      const {renderer, scene, camera} = mindarThree;
      
      // 🚫 移除光照 - 改为无光照渲染
      // const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
      // scene.add(light);
      
      const faceMesh = mindarThree.addFaceMesh();
      const texture = new THREE.TextureLoader().load('../enhanced_texture.png');
      
      // 🎭 加载透明度遮罩贴图 (眼睛和嘴部透明)
      const alphaTexture = new THREE.TextureLoader().load('../canonical_face_eyes.png');
      
      // 🎨 使用自定义Shader Material来实现反转的透明度遮罩
      const vertexShader = `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;
      
      const fragmentShader = `
        uniform sampler2D map;
        uniform sampler2D alphaMap;
        uniform float opacity;
        uniform vec3 color;
        varying vec2 vUv;
        
        void main() {
          vec4 texColor = texture2D(map, vUv);
          float alpha = texture2D(alphaMap, vUv).r;
          
          // 🎭 反转Alpha通道: 黑色(0)=不透明(1), 白色(1)=透明(0)
          alpha = 1.0 - alpha;
          
          // 结合材质透明度和遮罩透明度
          alpha = alpha * opacity;
          
          gl_FragColor = vec4(texColor.rgb * color, alpha);
        }
      `;
      
      // 🎨 替换为自定义Shader材质实现透明度遮罩
      unlitMaterial = new THREE.ShaderMaterial({
        uniforms: {
          map: { value: texture },
          alphaMap: { value: alphaTexture },
          opacity: { value: materialOpacity },
          color: { value: new THREE.Color(1, 1, 1) }
        },
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        transparent: true,
        depthWrite: false,
        fog: false
      });
      
      faceMesh.material = unlitMaterial;
      
      // 保存原始材质颜色 (Shader材质)
      originalMaterial = {
        color: unlitMaterial.uniforms.color.value.clone()
      };
      
      // 🔍 调试信息 - 显示材质类型
      console.log('🎨 材质类型:', unlitMaterial.type);
      console.log('🚫 光照模式: 无光照 (ShaderMaterial)');
      console.log('🔍 透明度模式: 半透明 + 透明度遮罩 (opacity:', materialOpacity + ')');
      console.log('🎭 透明度遮罩: canonical_face_eyes.png (黑色=不透明, 白色=透明)');
      console.log('💡 移除的光源: HemisphereLight');
               console.log('🎯 face-api.js 面部检测');
      
      scene.add(faceMesh);
      
      const start = async() => {
        await mindarThree.start();
        initColorSampling();
        
        // 🎯 加载 face-api.js 模型
        faceTrackingInitialized = await initFaceTracking();
        
        // 🎯 启动面部识别
        if (faceTrackingInitialized && mindarThree.video) {
          // 等待视频元数据加载完成
          const setupFaceTracking = () => {
            // 调整面部点位画布尺寸
            adjustFacePointsCanvas(mindarThree.video);
            
            const started = startFaceTracking(mindarThree.video);
            if (started) {
              updateFaceTrackingStatus('✅ 面部识别已启动');
            } else {
              updateFaceTrackingStatus('❌ 面部识别启动失败');
            }
          };
          
          if (mindarThree.video.readyState >= 2) {
            // 视频已经加载完成
            setupFaceTracking();
          } else {
            // 等待视频加载完成
            mindarThree.video.addEventListener('loadedmetadata', setupFaceTracking, { once: true });
          }
          
          // 监听视频尺寸变化和窗口大小变化
          mindarThree.video.addEventListener('resize', () => {
            adjustFacePointsCanvas(mindarThree.video);
          });
          
          // 监听窗口大小变化，重新调整缩放比例
          window.addEventListener('resize', () => {
            adjustFacePointsCanvas(mindarThree.video);
          });
        } else {
          updateFaceTrackingStatus('❌ 面部识别初始化失败');
        }
        
        renderer.setAnimationLoop(async () => {
          // 颜色处理
          if (useAutoColor) {
            const faceColor = sampleFaceColor(mindarThree.video);
            applyColorToFaceMesh(faceMesh, faceColor, colorIntensity, colorMode);
          } else {
            applyColorToFaceMesh(faceMesh, customColor, colorIntensity, colorMode);
          }
          
          // 🎯 性能监控
          const frameTime = performance.now();
          
          frameCount++;
          if (frameCount % 30 === 0) { // 每30帧更新一次FPS
            const deltaFrame = frameTime - lastFrameTime;
            avgFPS = 30000 / deltaFrame; // 30帧的平均FPS
            lastFrameTime = frameTime;
            
            // 更新性能信息显示
            updatePerformanceInfo(
              detectionInterval, 
              landmarkFilters !== null, 
              avgFPS
            );
          }
          
          // 🎯 关键点检测与绘制
          if (trackingStarted && mindarThree.video.readyState >= 2) {
            detectionCounter++;
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastDetectionTime) / 1000; // 转换为秒
            
            // 🎯 智能检测：根据运动状态调整检测频率
            const shouldDetect = detectionCounter % detectionInterval === 0 || !lastValidLandmarks;
            
            if (shouldDetect) {
              const detection = await faceapi.detectSingleFace(mindarThree.video, faceDetectorOptions).withFaceLandmarks(true);
              
              if (detection && detection.landmarks) {
                const rawLandmarks = detection.landmarks.positions;
                lastValidLandmarks = rawLandmarks;
                lastDetectionTime = currentTime;
                
                // 初始化滤波器（首次检测）
                if (!landmarkFilters) {
                  initLandmarkFilters(rawLandmarks.length);
                  currentLandmarks = rawLandmarks.map(pt => ({ x: pt.x, y: pt.y }));
                } else {
                  // 🎯 应用1€滤波器
                  currentLandmarks = rawLandmarks.map((pt, i) => ({
                    x: landmarkFilters[i].x.filter(pt.x, deltaTime || 1/30),
                    y: landmarkFilters[i].y.filter(pt.y, deltaTime || 1/30)
                  }));
                }
                
                // 🎯 动态调整检测频率：如果变化大，增加检测频率
                if (currentLandmarks && lastValidLandmarks) {
                  let maxMovement = 0;
                  for (let i = 0; i < Math.min(currentLandmarks.length, rawLandmarks.length); i++) {
                    const movement = Math.sqrt(
                      Math.pow(currentLandmarks[i].x - rawLandmarks[i].x, 2) +
                      Math.pow(currentLandmarks[i].y - rawLandmarks[i].y, 2)
                    );
                    maxMovement = Math.max(maxMovement, movement);
                  }
                  
                  // 运动大时每帧检测，运动小时降低频率
                  detectionInterval = maxMovement > 5 ? 1 : (maxMovement > 2 ? 2 : 3);
                }
              } else if (lastValidLandmarks && currentLandmarks) {
                // 🎯 检测失败时，保持上一帧的滤波结果，避免突然消失
                console.warn('⚠️ 当前帧检测失败，保持上一帧结果');
              }
            } else {
              // 🎯 跳帧时，使用预测或插值保持平滑
              if (currentLandmarks && deltaTime > 0) {
                // 轻微的预测性移动，基于历史运动趋势
                currentLandmarks = currentLandmarks.map((pt, i) => ({
                  x: landmarkFilters[i].x.filter(pt.x, deltaTime),
                  y: landmarkFilters[i].y.filter(pt.y, deltaTime)
                }));
              }
            }
            
            drawFacePoints();
          }
          
          // 先渲染场景
          renderer.render(scene, camera);
          
          // 🎬 画面合成：创建单层合成画面
          if (isCompositeEnabled && mindarThree.video) {
            const compositeFrame = createCompositeFrame(mindarThree.video, renderer, scene, camera);
            if (compositeFrame) {
              // 限制发送频率为30fps
              if (colorUpdateCounter % 2 === 0) {
                sendCompositeFrame(compositeFrame);
              }
            }
          }
          
          // 🎯 性能监控已移除（使用浏览器开发者工具代替）
        });
      }
      
      // 页面卸载时保存配置
      window.addEventListener('beforeunload', () => {
        const config = ColorPaletteManager.getCurrentConfig();
        ColorPaletteManager.saveConfig(config);
      });
      
      start();
    </script>
    <style>
      body {
        margin: 0;
        /* 🎯 让容器在页面上居中，并提供一个背景色 */
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100vh;
        background-color: #111;
      }
      #container {
        /* 🎯 遵循 clm_video.html 的方法，使用预设的初始显示尺寸 1280x720 */
        /* 这样可以确保视频流和容器的宽高比一致，避免 clmtrackr 坐标错位 */
        width: 1280px;
        height: 720px;
        position: relative;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div id="container">
    </div>
  </body>
</html>