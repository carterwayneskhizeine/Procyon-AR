<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <script type="module">
      import * as THREE from 'three';
      import { MindARThree } from '../src/face-target/three.js';
      import * as faceapi from 'face-api.js';
      import { OneEuroFilter } from '1eurofilter';
      
      // ğŸ¯ é¢éƒ¨è¯†åˆ«ç›¸å…³å˜é‡ (face-api.js)
      let trackingStarted = false;
      let faceDetectorOptions = null; // TinyFaceDetector é…ç½®
      let currentLandmarks = null;    // å¹³æ»‘åçš„å…³é”®ç‚¹
      let landmarkFilters = null;    // 1â‚¬ æ»¤æ³¢å™¨æ•°ç»„
      let facePointsCanvas = null;
      let facePointsCtx = null;
      
      // ğŸŒ WebSocket å…³é”®ç‚¹ä¼ è¾“ç›¸å…³å˜é‡
      let landmarkSocket = null;
      let isLandmarkSocketConnected = false;
      let landmarkSendCounter = 0;
      
      // ğŸ¨ å…±äº«è°ƒè‰²æ¿é…ç½®ç®¡ç†
      const ColorPaletteManager = {
        // é»˜è®¤é…ç½®
        defaultConfig: {
          customColor: { r: 0.9, g: 0.7, b: 0.6 },
          colorIntensity: 0.8,
          colorMode: 'multiply',
          useAutoColor: true,
          redValue: 230,
          greenValue: 179,
          blueValue: 153,
          materialOpacity: 0.7  // é»˜è®¤70%é€æ˜åº¦
        },
        
        // ä»localStorageåŠ è½½é…ç½®
        loadConfig() {
          try {
            const savedConfig = localStorage.getItem('raccoon-color-palette');
            if (savedConfig) {
              const config = JSON.parse(savedConfig);
              console.log('âœ… å·²åŠ è½½ä¿å­˜çš„è°ƒè‰²æ¿é…ç½®');
              return { ...this.defaultConfig, ...config };
            }
          } catch (error) {
            console.warn('âš ï¸ åŠ è½½è°ƒè‰²æ¿é…ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®:', error);
          }
          return this.defaultConfig;
        },
        
        // ä¿å­˜é…ç½®åˆ°localStorage
        saveConfig(config) {
          try {
            localStorage.setItem('raccoon-color-palette', JSON.stringify(config));
            console.log('ğŸ’¾ è°ƒè‰²æ¿é…ç½®å·²ä¿å­˜');
          } catch (error) {
            console.warn('âš ï¸ ä¿å­˜è°ƒè‰²æ¿é…ç½®å¤±è´¥:', error);
          }
        },
        
        // è·å–å½“å‰é…ç½®
        getCurrentConfig() {
          return {
            customColor: {
              r: customColor.r,
              g: customColor.g,
              b: customColor.b
            },
            colorIntensity,
            colorMode,
            useAutoColor,
            redValue: Math.round(customColor.r * 255),
            greenValue: Math.round(customColor.g * 255),
            blueValue: Math.round(customColor.b * 255),
            materialOpacity
          };
        }
      };
      
      // åŠ è½½ä¿å­˜çš„é…ç½®
      const savedConfig = ColorPaletteManager.loadConfig();
      
      // ğŸ¨ é¢œè‰²æ§åˆ¶è®¾ç½® - ä½¿ç”¨ä¿å­˜çš„é…ç½®åˆå§‹åŒ–
      let customColor = new THREE.Color(savedConfig.customColor.r, savedConfig.customColor.g, savedConfig.customColor.b);
      let colorIntensity = savedConfig.colorIntensity;
      let colorMode = savedConfig.colorMode;
      let useAutoColor = savedConfig.useAutoColor;
      
      // ğŸ” é€æ˜åº¦æ§åˆ¶è®¾ç½®
      let materialOpacity = savedConfig.materialOpacity || 0.7; // é»˜è®¤70%é€æ˜åº¦ï¼Œè®©äººè„¸å¯è§
      
      // é¢œè‰²é‡‡æ ·ç›¸å…³å˜é‡
      let colorCanvas = null;
      let colorCtx = null;
      let lastFaceColor = new THREE.Color(0.8, 0.6, 0.5);
      let colorUpdateCounter = 0;
      let originalMaterial = null; // ä¿å­˜åŸå§‹æè´¨
      let unlitMaterial = null; // ğŸ” å…¨å±€æè´¨å¼•ç”¨ï¼Œç”¨äºé€æ˜åº¦æ§åˆ¶
      
      // ğŸ¬ ç”»é¢åˆæˆç›¸å…³å˜é‡
      let compositeCanvas = null;
      let compositeCtx = null;
      let websocketServer = null;
      let isCompositeEnabled = true;
      
      // =========================
      // ï¿½ï¿½ï¸ åŠŸèƒ½å¼€å…³ï¼šFaceMeshè´´å›¾å±‚
      // true  - å¯ç”¨è´´å›¾å±‚ï¼ˆåŒå±‚åˆæˆï¼šæ‘„åƒæœº + FaceMeshï¼‰
      // false - ä»…è¾“å‡ºæ‘„åƒæœºç”»é¢ï¼ˆå•å±‚ï¼‰
      const USE_FACE_MESH_LAYER = false;
      // =========================
      
      // ğŸ¯ åˆå§‹åŒ–é¢éƒ¨è¯†åˆ«ç³»ç»Ÿ (face-api.js)
      const initFaceTracking = async () => {
        console.log('ğŸ¯ åˆå§‹åŒ–é¢éƒ¨è¯†åˆ«ç³»ç»Ÿ (face-api.js)...');

        try {
          // ï¿½ï¿½ ä¼˜å…ˆå°è¯•æœ¬åœ°æ¨¡å‹ï¼Œå¤±è´¥æ—¶ä½¿ç”¨ CDN
          let modelLoaded = false;
          
          try {
            console.log('ğŸ“¦ å°è¯•åŠ è½½æœ¬åœ°æ¨¡å‹...');
            await Promise.all([
              faceapi.nets.tinyFaceDetector.loadFromUri('./models'),
              faceapi.nets.faceLandmark68TinyNet.loadFromUri('./models')
            ]);
            modelLoaded = true;
            console.log('âœ… æœ¬åœ°æ¨¡å‹åŠ è½½æˆåŠŸ');
          } catch (localError) {
            console.warn('âš ï¸ æœ¬åœ°æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œå°è¯•CDNæ¨¡å‹:', localError.message);
            
            const MODEL_URL = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights';
            await Promise.all([
              faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
              faceapi.nets.faceLandmark68TinyNet.loadFromUri(MODEL_URL)
            ]);
            modelLoaded = true;
            console.log('âœ… CDNæ¨¡å‹åŠ è½½æˆåŠŸ');
          }
          
          faceDetectorOptions = new faceapi.TinyFaceDetectorOptions({ inputSize: 256, scoreThreshold: 0.5 });
          console.log('âœ… face-api.js æ¨¡å‹åŠ è½½å®Œæˆ');
        } catch (error) {
          console.error('âŒ face-api.js æ¨¡å‹åŠ è½½å¤±è´¥:', error);
          return false;
        }

        // åˆ›å»ºé¢éƒ¨ç‚¹ä½ç»˜åˆ¶ç”»å¸ƒ
        facePointsCanvas = document.createElement('canvas');
        facePointsCanvas.id = 'face-points-overlay';
        facePointsCanvas.style.position = 'absolute';
        facePointsCanvas.style.top = '0px';
        facePointsCanvas.style.left = '0px';
        facePointsCanvas.style.pointerEvents = 'none';
        facePointsCanvas.style.zIndex = '1000';
        facePointsCtx = facePointsCanvas.getContext('2d');

        // æ·»åŠ åˆ°å®¹å™¨
        const container = document.querySelector('#container');
        if (container) {
          container.appendChild(facePointsCanvas);
        }

        return true;
      };
      
      // ğŸ¯ åˆå§‹åŒ– 1â‚¬ æ»¤æ³¢å™¨ï¼ˆ68ä¸ªå…³é”®ç‚¹ Ã— 2åæ ‡ = 136ä¸ªæ»¤æ³¢å™¨ï¼‰
      const initLandmarkFilters = () => {
        console.log('ğŸ”§ åˆå§‹åŒ– 1â‚¬ æ»¤æ³¢å™¨...');
        
        // 1â‚¬ æ»¤æ³¢å™¨å‚æ•°ï¼šå¹³è¡¡å¹³æ»‘æ€§å’Œå»¶è¿Ÿ
        const filterParams = {
          freq: 30,        // ä¼°è®¡å¸§ç‡ 30fps
          mincutoff: 1.0,  // æœ€å°æˆªæ­¢é¢‘ç‡ï¼š1.0Hz = å¼ºå¹³æ»‘
          beta: 0.04,      // é€Ÿåº¦å“åº”ç³»æ•°ï¼š0.04 = ä½å»¶è¿Ÿ
          dcutoff: 1.0     // å¯¼æ•°æ»¤æ³¢æˆªæ­¢é¢‘ç‡
        };
        
        landmarkFilters = [];
        // ä¸º68ä¸ªå…³é”®ç‚¹çš„xã€yåæ ‡å„åˆ›å»ºæ»¤æ³¢å™¨
        for (let i = 0; i < 68; i++) {
          landmarkFilters.push({
            x: new OneEuroFilter(filterParams.freq, filterParams.mincutoff, filterParams.beta, filterParams.dcutoff),
            y: new OneEuroFilter(filterParams.freq, filterParams.mincutoff, filterParams.beta, filterParams.dcutoff)
          });
        }
        
        console.log('âœ… 1â‚¬ æ»¤æ³¢å™¨åˆå§‹åŒ–å®Œæˆï¼š68ä¸ªå…³é”®ç‚¹ Ã— 2åæ ‡ = 136ä¸ªæ»¤æ³¢å™¨');
      };
      
      // ğŸ¯ å¼€å§‹é¢éƒ¨è·Ÿè¸ª
      const startFaceTracking = (videoElement) => {
        if (!videoElement || !faceDetectorOptions) {
          console.warn('âš ï¸ face-api.js æœªå°±ç»ª');
          return false;
        }
        trackingStarted = true;
        console.log('âœ… é¢éƒ¨æ£€æµ‹å·²å¯åŠ¨');
        return true;
      };
      
      // ğŸ¯ ç»˜åˆ¶é¢éƒ¨ç‚¹ä½ï¼ˆå¸¦ç¼©æ”¾å’Œåç§»ï¼‰
      const drawFacePoints = () => {
        if (!facePointsCtx || !currentLandmarks) return;

        // æ¸…ç©ºç”»å¸ƒ
        facePointsCtx.clearRect(0, 0, facePointsCanvas.width, facePointsCanvas.height);

        facePointsCtx.save();
        // ğŸ¯ åº”ç”¨å˜æ¢ï¼šåç§» + ç¼©æ”¾ + æ°´å¹³ç¿»è½¬
        facePointsCtx.translate(videoOffsetX, videoOffsetY);
        facePointsCtx.scale(videoScaleX, videoScaleY);
        facePointsCtx.scale(-1, 1); // æ°´å¹³ç¿»è½¬åŒ¹é…è§†é¢‘
        facePointsCtx.translate(-facePointsCanvas.width / videoScaleX, 0);

        // ç»˜åˆ¶å…³é”®ç‚¹
        facePointsCtx.fillStyle = 'rgba(0,255,0,0.8)';
        currentLandmarks.forEach(pt => {
          facePointsCtx.beginPath();
          facePointsCtx.arc(pt.x, pt.y, 2, 0, Math.PI * 2);
          facePointsCtx.fill();
        });

        facePointsCtx.restore();
      };
      
      // ğŸ¯ è°ƒæ•´é¢éƒ¨ç‚¹ä½ç”»å¸ƒå°ºå¯¸å’Œç¼©æ”¾æ¯”ä¾‹
      let videoScaleX = 1;
      let videoScaleY = 1;
      let videoOffsetX = 0;
      let videoOffsetY = 0;
      
      const adjustFacePointsCanvas = (videoElement) => {
        if (!facePointsCanvas || !videoElement) return;
        
        const container = document.querySelector('#container');
        
        if (container && videoElement.videoWidth && videoElement.videoHeight) {
          // è®¾ç½®ç”»å¸ƒå°ºå¯¸ä¸å®¹å™¨ä¸€è‡´
          facePointsCanvas.width = container.clientWidth;
          facePointsCanvas.height = container.clientHeight;
          facePointsCanvas.style.width = container.clientWidth + 'px';
          facePointsCanvas.style.height = container.clientHeight + 'px';
          
          // ï¿½ï¿½ è®¡ç®—è§†é¢‘ç¼©æ”¾æ¯”ä¾‹ï¼ˆä»¿ç…§ MindAR çš„ç¼©æ”¾é€»è¾‘ï¼‰
          const videoRatio = videoElement.videoWidth / videoElement.videoHeight;
          const containerRatio = container.clientWidth / container.clientHeight;
          
          let displayWidth, displayHeight;
          if (videoRatio > containerRatio) {
            displayHeight = container.clientHeight;
            displayWidth = displayHeight * videoRatio;
          } else {
            displayWidth = container.clientWidth;
            displayHeight = displayWidth / videoRatio;
          }
          
          // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹å’Œåç§»é‡
          videoScaleX = displayWidth / videoElement.videoWidth;
          videoScaleY = displayHeight / videoElement.videoHeight;
          videoOffsetX = (container.clientWidth - displayWidth) / 2;
          videoOffsetY = (container.clientHeight - displayHeight) / 2;
          
          console.log('ğŸ¯ ç”»å¸ƒå°ºå¯¸å’Œç¼©æ”¾æ¯”ä¾‹è°ƒæ•´:', {
            canvasSize: `${facePointsCanvas.width}x${facePointsCanvas.height}`,
            videoOriginalSize: `${videoElement.videoWidth}x${videoElement.videoHeight}`,
            videoDisplaySize: `${displayWidth}x${displayHeight}`,
            scaleX: videoScaleX,
            scaleY: videoScaleY,
            offsetX: videoOffsetX,
            offsetY: videoOffsetY
          });
        }
      };
      
      // åˆ›å»ºé¢œè‰²æ§åˆ¶é¢æ¿
      const createColorControlPanel = () => {
        const controlPanel = document.createElement('div');
        controlPanel.id = 'color-control-panel';
        controlPanel.innerHTML = `
          <div style="position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.85); color: white; padding: 15px; border-radius: 8px; font-family: Arial, sans-serif; font-size: 12px; z-index: 1001; width: 250px;">
            <h3 style="margin: 0 0 10px 0; color: #FFD700;">ğŸ¨ å…±äº«è°ƒè‰²æ¿ + ğŸ¯ é¢éƒ¨è¯†åˆ«</h3>
            
            <div style="margin-bottom: 10px; padding: 8px; background: #333; border-radius: 4px;">
              <div style="color: #00FF00; font-weight: bold; margin-bottom: 5px;">ğŸ¯ é¢éƒ¨è¯†åˆ«çŠ¶æ€</div>
              <div id="faceTrackingStatus" style="color: #888;">åˆå§‹åŒ–ä¸­...</div>
              <div style="font-size: 10px; color: #666; margin-top: 3px;">face-api.js + 1â‚¬æ»¤æ³¢å™¨ (ä½å»¶è¿ŸæŠ—æŠ–åŠ¨)</div>
            </div>
            
            <div style="margin-bottom: 10px;">
              <label style="display: block; margin-bottom: 5px;">é¢œè‰²æ¨¡å¼:</label>
              <select id="colorModeSelect" style="width: 100%; padding: 3px; background: #333; color: white; border: 1px solid #555;">
                <option value="multiply">ä¹˜æ³•æ··åˆ (æ¨è)</option>
                <option value="overlay">å åŠ æ··åˆ</option>
                <option value="lerp">çº¿æ€§æ’å€¼</option>
              </select>
            </div>
            
            <div style="margin-bottom: 10px;">
              <label style="display: block; margin-bottom: 5px;">
                <input type="checkbox" id="useAutoColorCheck" ${useAutoColor ? 'checked' : ''}> è‡ªåŠ¨è‚¤è‰²é‡‡æ ·
              </label>
            </div>
            
            <div id="manualColorControls" style="display: ${useAutoColor ? 'none' : 'block'};">
              <div style="margin-bottom: 8px;">
                <label style="display: block; margin-bottom: 3px;">è‡ªå®šä¹‰é¢œè‰²:</label>
                <input type="color" id="customColorPicker" style="width: 100%; height: 30px; border: none; border-radius: 4px;">
              </div>
            </div>
            
            <div style="margin-bottom: 8px;">
              <label style="display: block; margin-bottom: 3px;">å¼ºåº¦: <span id="intensityValue">${Math.round(colorIntensity * 100)}%</span></label>
              <input type="range" id="intensitySlider" min="0" max="100" value="${Math.round(colorIntensity * 100)}" style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 8px;">
              <label style="display: block; margin-bottom: 3px;">é€æ˜åº¦: <span id="opacityValue">${Math.round(materialOpacity * 100)}%</span></label>
              <input type="range" id="opacitySlider" min="0" max="100" value="${Math.round(materialOpacity * 100)}" style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 8px;">
              <label style="display: block; margin-bottom: 3px;">çº¢è‰²: <span id="redValue">${savedConfig.redValue}</span></label>
              <input type="range" id="redSlider" min="0" max="255" value="${savedConfig.redValue}" style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 8px;">
              <label style="display: block; margin-bottom: 3px;">ç»¿è‰²: <span id="greenValue">${savedConfig.greenValue}</span></label>
              <input type="range" id="greenSlider" min="0" max="255" value="${savedConfig.greenValue}" style="width: 100%;">
            </div>
            
            <div style="margin-bottom: 10px;">
              <label style="display: block; margin-bottom: 3px;">è“è‰²: <span id="blueValue">${savedConfig.blueValue}</span></label>
              <input type="range" id="blueSlider" min="0" max="255" value="${savedConfig.blueValue}" style="width: 100%;">
            </div>
            
            <div style="background: #333; padding: 8px; border-radius: 4px; text-align: center;">
              <div id="colorPreview" style="width: 100%; height: 20px; border-radius: 3px; margin-bottom: 5px;"></div>
              <span id="colorHex"></span>
            </div>
            
            <div style="margin-top: 10px; text-align: center;">
              <button id="resetColorBtn" style="background: #555; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-right: 5px;">é‡ç½®</button>
              <button id="warmToneBtn" style="background: #8B4513; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">æš–è‰²è°ƒ</button>
            </div>
            
            <div style="margin-top: 8px; font-size: 9px; color: #888; text-align: center;">
              é…ç½®è‡ªåŠ¨åŒæ­¥åˆ°Meshç‰ˆæœ¬<br/>
              ğŸ­ é€æ˜åº¦é®ç½© + åŠé€æ˜ | ShaderMaterial<br/>
              ğŸ¯ face-api.js + 1â‚¬æ»¤æ³¢å™¨ + é¢éƒ¨è½®å»“
            </div>

            <details style="margin-top: 8px;">
              <summary style="cursor: pointer; color: #FFD700; font-size: 11px;">ğŸ”§ 1â‚¬æ»¤æ³¢å™¨å‚æ•°è°ƒèŠ‚</summary>
              <div style="margin-top: 5px; font-size: 10px;">
                <div style="margin-bottom: 5px;">
                  <label>MinCutoff (å¹³æ»‘åº¦): <span id="minCutoffValue">1.0</span></label>
                  <input type="range" id="minCutoffSlider" min="0.1" max="2.0" step="0.1" value="1.0" style="width: 100%;">
                </div>
                <div style="margin-bottom: 5px;">
                  <label>Beta (å“åº”é€Ÿåº¦): <span id="betaValue">0.04</span></label>
                  <input type="range" id="betaSlider" min="0.01" max="0.2" step="0.01" value="0.04" style="width: 100%;">
                </div>
                <div style="color: #666; font-size: 9px;">
                  MinCutoffâ†“=æ›´å¹³æ»‘ä½†å»¶è¿Ÿâ†‘<br/>
                  Betaâ†‘=è·Ÿéšæ›´å¿«ä½†å¯èƒ½æŠ–åŠ¨â†‘
                </div>
                <div style="margin-top: 8px; text-align: center;">
                  <button id="smoothPreset" style="background: #555; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; margin-right: 3px; font-size: 9px;">å¹³æ»‘ä¼˜å…ˆ</button>
                  <button id="balancedPreset" style="background: #555; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; margin-right: 3px; font-size: 9px;">å¹³è¡¡æ¨¡å¼</button>
                  <button id="responsivePreset" style="background: #555; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;">å“åº”ä¼˜å…ˆ</button>
                </div>
              </div>
            </details>
          </div>
        `;
        document.body.appendChild(controlPanel);
        
        setupColorControlEvents();
      };
      
      // è®¾ç½®é¢œè‰²æ§åˆ¶äº‹ä»¶
      const setupColorControlEvents = () => {
        const colorModeSelect = document.getElementById('colorModeSelect');
        const useAutoColorCheck = document.getElementById('useAutoColorCheck');
        const manualColorControls = document.getElementById('manualColorControls');
        const customColorPicker = document.getElementById('customColorPicker');
        const intensitySlider = document.getElementById('intensitySlider');
        const opacitySlider = document.getElementById('opacitySlider');
        const redSlider = document.getElementById('redSlider');
        const greenSlider = document.getElementById('greenSlider');
        const blueSlider = document.getElementById('blueSlider');
        
        // è®¾ç½®åˆå§‹å€¼
        colorModeSelect.value = colorMode;
        
        // è‡ªåŠ¨ä¿å­˜é…ç½®çš„å‡½æ•°
        const saveCurrentConfig = () => {
          const config = ColorPaletteManager.getCurrentConfig();
          ColorPaletteManager.saveConfig(config);
        };
        
        // é¢œè‰²æ¨¡å¼åˆ‡æ¢
        colorModeSelect.addEventListener('change', (e) => {
          colorMode = e.target.value;
          saveCurrentConfig();
        });
        
        // è‡ªåŠ¨/æ‰‹åŠ¨é¢œè‰²åˆ‡æ¢
        useAutoColorCheck.addEventListener('change', (e) => {
          useAutoColor = e.target.checked;
          manualColorControls.style.display = useAutoColor ? 'none' : 'block';
          saveCurrentConfig();
        });
        
        // æ›´æ–°é¢œè‰²çš„å‡½æ•°
        const updateColor = () => {
          const r = parseInt(redSlider.value);
          const g = parseInt(greenSlider.value);
          const b = parseInt(blueSlider.value);
          
          customColor.setRGB(r / 255, g / 255, b / 255);
          colorIntensity = parseInt(intensitySlider.value) / 100;
          materialOpacity = parseInt(opacitySlider.value) / 100;
          
          // ğŸ” å®æ—¶æ›´æ–°æè´¨é€æ˜åº¦ (Shaderæè´¨)
          if (unlitMaterial && unlitMaterial.uniforms) {
            unlitMaterial.uniforms.opacity.value = materialOpacity;
            unlitMaterial.needsUpdate = true;
          }
          
          // æ›´æ–°æ˜¾ç¤º
          document.getElementById('redValue').textContent = r;
          document.getElementById('greenValue').textContent = g;
          document.getElementById('blueValue').textContent = b;
          document.getElementById('intensityValue').textContent = Math.round(colorIntensity * 100) + '%';
          document.getElementById('opacityValue').textContent = Math.round(materialOpacity * 100) + '%';
          
          const colorPreview = document.getElementById('colorPreview');
          const colorHex = document.getElementById('colorHex');
          const hexColor = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
          
          colorPreview.style.background = `rgba(${r}, ${g}, ${b}, ${materialOpacity})`;
          colorHex.textContent = hexColor;
          customColorPicker.value = hexColor;
          
          // è‡ªåŠ¨ä¿å­˜é…ç½®
          saveCurrentConfig();
        };
        
        // ç»‘å®šæ»‘å—äº‹ä»¶
        intensitySlider.addEventListener('input', updateColor);
        opacitySlider.addEventListener('input', updateColor);
        redSlider.addEventListener('input', updateColor);
        greenSlider.addEventListener('input', updateColor);
        blueSlider.addEventListener('input', updateColor);
        
        // é¢œè‰²é€‰æ‹©å™¨äº‹ä»¶
        customColorPicker.addEventListener('change', (e) => {
          const hex = e.target.value;
          const r = parseInt(hex.substr(1, 2), 16);
          const g = parseInt(hex.substr(3, 2), 16);
          const b = parseInt(hex.substr(5, 2), 16);
          
          redSlider.value = r;
          greenSlider.value = g;
          blueSlider.value = b;
          updateColor();
        });
        
        // é¢„è®¾é¢œè‰²æŒ‰é’®äº‹ä»¶
        const resetColorBtn = document.getElementById('resetColorBtn');
        const warmToneBtn = document.getElementById('warmToneBtn');
        
        resetColorBtn.addEventListener('click', () => {
          redSlider.value = 230;
          greenSlider.value = 179;
          blueSlider.value = 153;
          intensitySlider.value = 80;
          opacitySlider.value = 70;  // é‡ç½®é€æ˜åº¦ä¸º70%
          updateColor();
        });
        
        warmToneBtn.addEventListener('click', () => {
          redSlider.value = 210;
          greenSlider.value = 150;
          blueSlider.value = 120;
          intensitySlider.value = 75;
          opacitySlider.value = 70;  // æš–è‰²è°ƒä¹Ÿè®¾ç½®70%é€æ˜åº¦
          updateColor();
        });
        
        // åˆå§‹åŒ–æ˜¾ç¤º
        updateColor();
        
        // ğŸ”§ 1â‚¬æ»¤æ³¢å™¨å‚æ•°æ§åˆ¶
        const minCutoffSlider = document.getElementById('minCutoffSlider');
        const betaSlider = document.getElementById('betaSlider');
        const minCutoffValue = document.getElementById('minCutoffValue');
        const betaValue = document.getElementById('betaValue');
        
        if (minCutoffSlider && betaSlider) {
          minCutoffSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            minCutoffValue.textContent = value.toFixed(1);
            // æ›´æ–°æ‰€æœ‰æ»¤æ³¢å™¨çš„ minCutoff å‚æ•°
            if (landmarkFilters) {
              landmarkFilters.forEach(filter => {
                filter.x.setMinCutoff(value);
                filter.y.setMinCutoff(value);
              });
            }
          });
          
          betaSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            betaValue.textContent = value.toFixed(2);
            // æ›´æ–°æ‰€æœ‰æ»¤æ³¢å™¨çš„ beta å‚æ•°
            if (landmarkFilters) {
              landmarkFilters.forEach(filter => {
                filter.x.setBeta(value);
                filter.y.setBeta(value);
              });
            }
          });
        }
        
        // ğŸ¯ é¢„è®¾æŒ‰é’®äº‹ä»¶å¤„ç†
        const smoothPreset = document.getElementById('smoothPreset');
        const balancedPreset = document.getElementById('balancedPreset');
        const responsivePreset = document.getElementById('responsivePreset');
        
        const applyPreset = (minCutoff, beta) => {
          if (minCutoffSlider && betaSlider) {
            minCutoffSlider.value = minCutoff;
            betaSlider.value = beta;
            minCutoffValue.textContent = minCutoff.toFixed(1);
            betaValue.textContent = beta.toFixed(2);
            
            if (landmarkFilters) {
              landmarkFilters.forEach(filter => {
                filter.x.setMinCutoff(minCutoff);
                filter.x.setBeta(beta);
                filter.y.setMinCutoff(minCutoff);
                filter.y.setBeta(beta);
              });
            }
          }
        };
        
        if (smoothPreset) {
          smoothPreset.addEventListener('click', () => applyPreset(0.5, 0.02)); // å¼ºå¹³æ»‘ï¼Œä½å“åº”
        }
        if (balancedPreset) {
          balancedPreset.addEventListener('click', () => applyPreset(1.0, 0.04)); // é»˜è®¤å¹³è¡¡
        }
        if (responsivePreset) {
          responsivePreset.addEventListener('click', () => applyPreset(1.5, 0.08)); // å¼±å¹³æ»‘ï¼Œé«˜å“åº”
        }
      };
      
      // ğŸ¯ æ›´æ–°é¢éƒ¨è¯†åˆ«çŠ¶æ€æ˜¾ç¤º
      const updateFaceTrackingStatus = (status) => {
        const statusElement = document.getElementById('faceTrackingStatus');
        if (statusElement) {
          statusElement.textContent = status;
        }
      };
      
      // åˆå§‹åŒ–é¢œè‰²é‡‡æ ·Canvas
      const initColorSampling = () => {
        colorCanvas = document.createElement('canvas');
        colorCanvas.width = 64;
        colorCanvas.height = 64;
        colorCtx = colorCanvas.getContext('2d');
      };
      
      // ä»è§†é¢‘ä¸­é‡‡æ ·äººè„¸é¢œè‰²
      const sampleFaceColor = (video) => {
        if (!colorCtx) return lastFaceColor;
        
        try {
          colorUpdateCounter++;
          if (colorUpdateCounter % 10 !== 0) return lastFaceColor;
          
          colorCtx.drawImage(video, 0, 0, colorCanvas.width, colorCanvas.height);
          
          const centerX = Math.floor(colorCanvas.width * 0.5);
          const centerY = Math.floor(colorCanvas.height * 0.4);
          const sampleSize = 20;
          
          let r = 0, g = 0, b = 0, count = 0;
          
          for (let x = centerX - sampleSize; x < centerX + sampleSize; x++) {
            for (let y = centerY - sampleSize; y < centerY + sampleSize; y++) {
              if (x >= 0 && x < colorCanvas.width && y >= 0 && y < colorCanvas.height) {
                const imageData = colorCtx.getImageData(x, y, 1, 1);
                const [pr, pg, pb] = imageData.data;
                
                if (pr > 30 && pr < 240 && pg > 30 && pg < 240 && pb > 30 && pb < 240) {
                  r += pr;
                  g += pg;
                  b += pb;
                  count++;
                }
              }
            }
          }
          
          if (count > 0) {
            r /= count;
            g /= count;
            b /= count;
            
            const newColor = new THREE.Color(r / 255, g / 255, b / 255);
            lastFaceColor.lerp(newColor, 0.1);
          }
          
        } catch (error) {
          console.warn('é¢œè‰²é‡‡æ ·å¤±è´¥:', error);
        }
        
        return lastFaceColor;
      };
      
      // åº”ç”¨é¢œè‰²åˆ°FaceMesh (Shaderæè´¨ç‰ˆæœ¬)
      const applyColorToFaceMesh = (faceMesh, faceColor, intensity, mode) => {
        if (!faceMesh || !faceMesh.material || !originalMaterial || !faceMesh.material.uniforms) return;
        
        let blendedColor = new THREE.Color();
        
        if (mode === 'multiply') {
          blendedColor.copy(faceColor).multiply(originalMaterial.color);
        } else if (mode === 'overlay') {
          const base = originalMaterial.color;
          const overlay = faceColor;
          blendedColor.setRGB(
            base.r < 0.5 ? 2 * base.r * overlay.r : 1 - 2 * (1 - base.r) * (1 - overlay.r),
            base.g < 0.5 ? 2 * base.g * overlay.g : 1 - 2 * (1 - base.g) * (1 - overlay.g),
            base.b < 0.5 ? 2 * base.b * overlay.b : 1 - 2 * (1 - base.b) * (1 - overlay.b)
          );
        } else {
          blendedColor.copy(originalMaterial.color).lerp(faceColor, intensity);
        }
        
        if (mode !== 'lerp') {
          blendedColor.lerp(originalMaterial.color, 1 - intensity);
        }
        
        // ğŸ¨ æ›´æ–°Shaderæè´¨çš„é¢œè‰²uniform
        faceMesh.material.uniforms.color.value.copy(blendedColor);
        faceMesh.material.needsUpdate = true;
      };
      
      // ğŸ¬ ç”»é¢åˆæˆç³»ç»Ÿåˆå§‹åŒ–
      const initCompositeSystem = () => {
        console.log('ğŸ¬ åˆå§‹åŒ–ç”»é¢åˆæˆç³»ç»Ÿ...');
        
        // åˆ›å»ºåˆæˆç”»å¸ƒ
        compositeCanvas = document.createElement('canvas');
        compositeCanvas.width = 640;
        compositeCanvas.height = 480;
        compositeCtx = compositeCanvas.getContext('2d');
        
        // åˆå§‹åŒ–WebSocketæœåŠ¡å™¨
        initWebSocketServer();
        
        console.log('âœ… ç”»é¢åˆæˆç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
      };
      
      // ğŸŒ åˆå§‹åŒ–WebSocketæœåŠ¡å™¨
      const initWebSocketServer = () => {
        try {
          // å°è¯•è¿æ¥åˆ°WebSocketæœåŠ¡å™¨
          websocketServer = new WebSocket('ws://localhost:3002?type=sender');
          
          websocketServer.onopen = () => {
            console.log('âœ… WebSocketæœåŠ¡å™¨è¿æ¥æˆåŠŸ');
            isCompositeEnabled = true;
          };
          
          websocketServer.onclose = () => {
            console.log('âŒ WebSocketæœåŠ¡å™¨è¿æ¥æ–­å¼€');
            isCompositeEnabled = false;
            
            // 5ç§’åå°è¯•é‡è¿
            setTimeout(() => {
              if (!isCompositeEnabled) {
                initWebSocketServer();
              }
            }, 5000);
          };
          
          websocketServer.onerror = (error) => {
            console.warn('âš ï¸ WebSocketè¿æ¥å¤±è´¥ï¼Œå°†ä½¿ç”¨HTTP APIå¤‡é€‰æ–¹æ¡ˆ:', error);
            isCompositeEnabled = false;
          };
          
        } catch (error) {
          console.warn('âš ï¸ WebSocketåˆå§‹åŒ–å¤±è´¥ï¼Œå°†ä½¿ç”¨HTTP APIå¤‡é€‰æ–¹æ¡ˆ:', error);
          isCompositeEnabled = false;
        }
      };
      
      // ğŸ¬ åˆæˆä¸¤å±‚ç”»é¢ä¸ºå•å±‚åƒç´ ç”»é¢
      const createCompositeFrame = (videoElement, threeRenderer, scene, camera) => {
        if (!compositeCanvas || !compositeCtx || !videoElement) return null;
        
        try {
          // ç¡®ä¿ç”»å¸ƒå°ºå¯¸ä¸è§†é¢‘åŒ¹é…
          if (compositeCanvas.width !== videoElement.videoWidth || 
              compositeCanvas.height !== videoElement.videoHeight) {
            compositeCanvas.width = videoElement.videoWidth || 640;
            compositeCanvas.height = videoElement.videoHeight || 480;
          }
          
          // æ¸…ç©ºç”»å¸ƒ
          compositeCtx.clearRect(0, 0, compositeCanvas.width, compositeCanvas.height);
          
          // ç¬¬ä¸€å±‚ï¼šç»˜åˆ¶åŸå§‹è§†é¢‘ç”»é¢ï¼ˆä¸ç¿»è½¬ï¼Œä¿æŒåŸå§‹æ–¹å‘ï¼‰
          compositeCtx.drawImage(videoElement, 0, 0, compositeCanvas.width, compositeCanvas.height);
          
          // ç¬¬äºŒå±‚ï¼šè·å–Three.jsæ¸²æŸ“ç»“æœ
          const threeCanvas = threeRenderer.domElement;
          if (USE_FACE_MESH_LAYER && threeCanvas) {
            // è®¾ç½®æ··åˆæ¨¡å¼ä¸ºæ­£å¸¸æ¨¡å¼ï¼Œç¡®ä¿çœŸå®åƒç´ åˆæˆ
            compositeCtx.globalCompositeOperation = 'source-over';
            
            // ç»˜åˆ¶Three.jsæ¸²æŸ“çš„é¢éƒ¨ç½‘æ ¼ï¼ˆæ°´å¹³ç¿»è½¬ä»¥åŒ¹é…è§†é¢‘ï¼‰
            compositeCtx.save();
            compositeCtx.scale(-1, 1); // æ°´å¹³ç¿»è½¬
            compositeCtx.translate(-compositeCanvas.width, 0);
            compositeCtx.drawImage(threeCanvas, 0, 0, compositeCanvas.width, compositeCanvas.height);
            compositeCtx.restore();
          }
          
          // é‡ç½®æ··åˆæ¨¡å¼
          compositeCtx.globalCompositeOperation = 'source-over';
          
          return compositeCanvas;
          
        } catch (error) {
          console.error('âŒ ç”»é¢åˆæˆå¤±è´¥:', error);
          return null;
        }
      };
      
      // ğŸš€ å‘é€åˆæˆç”»é¢
      const sendCompositeFrame = (compositeCanvas) => {
        if (!compositeCanvas || !isCompositeEnabled) return;
        
        try {
          // è½¬æ¢ä¸ºBlobæ•°æ®
          compositeCanvas.toBlob((blob) => {
            if (websocketServer && websocketServer.readyState === WebSocket.OPEN) {
              // é€šè¿‡WebSocketå‘é€
              websocketServer.send(blob);
            } else {
              // å¤‡é€‰æ–¹æ¡ˆï¼šé€šè¿‡HTTP APIå‘é€
              sendCompositeFrameHTTP(blob);
            }
          }, 'image/jpeg', 0.85); // ä½¿ç”¨JPEGæ ¼å¼ï¼Œ85%è´¨é‡
          
        } catch (error) {
          console.error('âŒ å‘é€åˆæˆç”»é¢å¤±è´¥:', error);
        }
      };
      
      // ğŸ“¡ HTTP APIå¤‡é€‰æ–¹æ¡ˆ
      const sendCompositeFrameHTTP = async (blob) => {
        try {
          const formData = new FormData();
          formData.append('composite-frame', blob, 'composite.jpg');
          
          await fetch('http://localhost:3001/api/composite-frame', {
            method: 'POST',
            body: formData
          });
          
        } catch (error) {
          console.warn('âš ï¸ HTTPå‘é€åˆæˆç”»é¢å¤±è´¥:', error);
        }
      };
      
      // ğŸŒ 68â†’71 æ˜ å°„å‡½æ•° (åŸºäºç”¨æˆ·ç´¢å¼•æ˜ å°„è¡¨ - æ— é‡å¤ç‰ˆæœ¬)
      const mapping68to71 = {
        // ä¸‹é¢Œçº¿ dlib 0-14 â†’ clm 0-14 
        0: 0,   // dlib 0 â†’ clm 0
        1: 1,   // dlib 1 â†’ clm 1  
        2: 2,   // dlib 2 â†’ clm 2
        3: 3,   // dlib 3 â†’ clm 3
        4: 4,   // dlib 4 â†’ clm 4
        5: 5,   // dlib 5 â†’ clm 5
        6: 6,   // dlib 6 â†’ clm 6
        7: 7,   // dlib 7 â†’ clm 7
        8: 8,   // dlib 8 â†’ clm 8
        9: 9,   // dlib 9 â†’ clm 9
        10: 10, // dlib 10 â†’ clm 10
        11: 11, // dlib 11 â†’ clm 11
        12: 12, // dlib 12 â†’ clm 12
        13: 13, // dlib 13 â†’ clm 13
        14: 14, // dlib 14 â†’ clm 14
        // è·³è¿‡ dlib 15,16 (dlibæœ‰17ä¸ªä¸‹é¢Œç‚¹ï¼Œclmåªæœ‰15ä¸ª)
        
        // å·¦çœ‰ dlib 17-21 â†’ clm 19-22
        17: 19, // dlib 17 â†’ clm 19
        18: 20, // dlib 18 â†’ clm 20
        19: 21, // dlib 19 â†’ clm 21 
        20: 22, // dlib 20 â†’ clm 22
        // è·³è¿‡ dlib 21
        
        // å³çœ‰ dlib 22-26 â†’ clm 15-18
        22: 18, // dlib 22 â†’ clm 18
        23: 17, // dlib 23 â†’ clm 17
        24: 16, // dlib 24 â†’ clm 16 
        25: 15, // dlib 25 â†’ clm 15
        // è·³è¿‡ dlib 26
        
        // é¼»æ¢ dlib 27-30 â†’ clm 33,41,39,62
        27: 33, // dlib 27 â†’ clm 33 (é¼»æ ¹)
        28: 41, // dlib 28 â†’ clm 41 (é¼»æ¢ä¸­ç‚¹)
        29: 39, // dlib 29 â†’ clm 39 (é¼»æ¢ä¸­æ®µ)
        30: 62, // dlib 30 â†’ clm 62 (é¼»å°–ä¸Šæ–¹)
        
        // é¼»ç¿¼ dlib 31-35 â†’ clm 34,42,37,43,38
        31: 34, // dlib 31 â†’ clm 34
        32: 42, // dlib 32 â†’ clm 42  
        33: 37, // dlib 33 â†’ clm 37 (é¼»æŸ±åº•éƒ¨)
        34: 43, // dlib 34 â†’ clm 43
        35: 38, // dlib 35 â†’ clm 38
        
        // å·¦çœ¼ dlib 36-41 â†’ clm 23,63,64,25,65,66
        36: 23, // dlib 36 â†’ clm 23 (å·¦çœ¼å¤–è§’)
        37: 63, // dlib 37 â†’ clm 63
        38: 64, // dlib 38 â†’ clm 64
        39: 25, // dlib 39 â†’ clm 25 (å·¦çœ¼ä¸Šç¼˜å†…)
        40: 65, // dlib 40 â†’ clm 65
        41: 66, // dlib 41 â†’ clm 66
        
        // å³çœ¼ dlib 42-47 â†’ clm 30,68,67,28,70,69
        42: 30, // dlib 42 â†’ clm 30 (å³çœ¼å†…è§’)
        43: 68, // dlib 43 â†’ clm 68
        44: 67, // dlib 44 â†’ clm 67 (å³çœ¼ä¸Šç¼˜å¤–)
        45: 28, // dlib 45 â†’ clm 28 (å³çœ¼å¤–è§’)
        46: 70, // dlib 46 â†’ clm 70
        47: 69, // dlib 47 â†’ clm 69
        
        // å˜´å·´å¤–è½®å»“ dlib 48-59 â†’ clm 44-55
        48: 44, // dlib 48 â†’ clm 44 (å·¦å˜´è§’)
        49: 45, // dlib 49 â†’ clm 45
        50: 46, // dlib 50 â†’ clm 46
        51: 47, // dlib 51 â†’ clm 47
        52: 48, // dlib 52 â†’ clm 48
        53: 49, // dlib 53 â†’ clm 49
        54: 50, // dlib 54 â†’ clm 50 
        55: 51, // dlib 55 â†’ clm 51
        56: 52, // dlib 56 â†’ clm 52
        57: 53, // dlib 57 â†’ clm 53
        58: 54, // dlib 58 â†’ clm 54
        59: 55, // dlib 59 â†’ clm 55
        
        // å˜´å·´å†…è½®å»“ dlib 60-65 â†’ clm 56-61
        60: 56, // dlib 60 â†’ clm 56 
        61: 57, // dlib 61 â†’ clm 57
        62: 58, // dlib 62 â†’ clm 58
        63: 59, // dlib 63 â†’ clm 59
        64: 60, // dlib 64 â†’ clm 60
        65: 61, // dlib 65 â†’ clm 61
        // è·³è¿‡ dlib 66,67 å› ä¸º clm å†…è½®å»“åªæœ‰6ä¸ªç‚¹
      };

      function convert68to71(pts68) {
        const pts71 = new Array(71);
        
        // ä½¿ç”¨æ˜ å°„è¡¨å¡«å……
        for (let clmIdx = 0; clmIdx < 71; clmIdx++) {
          const dlibIdx = mapping68to71[clmIdx];
          if (dlibIdx !== undefined && pts68[dlibIdx]) {
            pts71[clmIdx] = [pts68[dlibIdx].x, pts68[dlibIdx].y];
          }
        }
        
        // æ’å€¼è®¡ç®—ç‰¹æ®Šç‚¹
        if (pts68.length >= 48) {
          // å·¦çœ¼ä¸­å¿ƒ (27) - ä½¿ç”¨ clm 23 å’Œ 25 çš„ä¸­ç‚¹
          if (pts71[23] && pts71[25]) {
            pts71[27] = [
              (pts71[23][0] + pts71[25][0]) / 2,
              (pts71[23][1] + pts71[25][1]) / 2
            ];
          }
          
          // å³çœ¼ä¸­å¿ƒ (32) - ä½¿ç”¨ clm 30 å’Œ 28 çš„ä¸­ç‚¹
          if (pts71[30] && pts71[28]) {
            pts71[32] = [
              (pts71[30][0] + pts71[28][0]) / 2,
              (pts71[30][1] + pts71[28][1]) / 2
            ];
          }
          
          // å·¦çœ¼é¢å¤–æ’å€¼ç‚¹
          if (pts71[63] && pts71[64]) {
            pts71[24] = [
              (pts71[63][0] + pts71[64][0]) / 2,
              (pts71[63][1] + pts71[64][1]) / 2
            ];
          }
          
          if (pts71[66] && pts71[65]) {
            pts71[26] = [
              (pts71[66][0] + pts71[65][0]) / 2,
              (pts71[66][1] + pts71[65][1]) / 2
            ];
          }
          
          // å³çœ¼é¢å¤–æ’å€¼ç‚¹
          if (pts71[68] && pts71[67]) {
            pts71[29] = [
              (pts71[68][0] + pts71[67][0]) / 2,
              (pts71[68][1] + pts71[67][1]) / 2
            ];
          }
          
          if (pts71[69] && pts71[70]) {
            pts71[31] = [
              (pts71[69][0] + pts71[70][0]) / 2,
              (pts71[69][1] + pts71[70][1]) / 2
            ];
          }
          
          // é¼»å­é¢å¤–æ’å€¼ç‚¹
          if (pts71[34] && pts71[38]) {
            pts71[35] = [pts71[34][0], pts71[34][1]]; // ä½¿ç”¨å·¦é¼»ç¿¼
            pts71[36] = [pts71[34][0], pts71[34][1]]; // ä½¿ç”¨å·¦é¼»ç¿¼
            pts71[40] = [pts71[38][0], pts71[38][1]]; // ä½¿ç”¨å³é¼»ç¿¼
          }
        }
        
        // å¡«å……æœªå®šä¹‰çš„ç‚¹ï¼ˆä½¿ç”¨ç¬¬ä¸€ä¸ªç‚¹ä½œä¸ºé»˜è®¤å€¼ï¼‰
        for (let i = 0; i < 71; i++) {
          if (!pts71[i] && pts68[0]) {
            pts71[i] = [pts68[0].x, pts68[0].y];
          }
        }
        
        return pts71;
      }

      // ğŸŒ åˆå§‹åŒ–å…³é”®ç‚¹ä¼ è¾“ WebSocket
      const initLandmarkSocket = () => {
        try {
          console.log('ğŸŒ è¿æ¥å…³é”®ç‚¹ä¼ è¾“æœåŠ¡å™¨...');
          landmarkSocket = new WebSocket('ws://localhost:3003?type=source');
          
          landmarkSocket.onopen = () => {
            console.log('âœ… å…³é”®ç‚¹ä¼ è¾“ WebSocket è¿æ¥æˆåŠŸ');
            isLandmarkSocketConnected = true;
            updateFaceTrackingStatus('âœ… é¢éƒ¨è¯†åˆ«å·²å¯åŠ¨ + WebSocketè¿æ¥æˆåŠŸ');
          };
          
          landmarkSocket.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              if (message.type === 'welcome') {
                console.log('ğŸŒ æ”¶åˆ°æ¬¢è¿æ¶ˆæ¯:', message.message);
              }
            } catch (error) {
              console.warn('âš ï¸ WebSocket æ¶ˆæ¯è§£æå¤±è´¥:', error);
            }
          };
          
          landmarkSocket.onclose = () => {
            console.log('âŒ å…³é”®ç‚¹ä¼ è¾“ WebSocket è¿æ¥æ–­å¼€');
            isLandmarkSocketConnected = false;
            updateFaceTrackingStatus('âš ï¸ é¢éƒ¨è¯†åˆ«è¿è¡Œä¸­ï¼ŒWebSocketå·²æ–­å¼€');
            
            // 5ç§’åå°è¯•é‡è¿
            setTimeout(() => {
              if (!isLandmarkSocketConnected) {
                initLandmarkSocket();
              }
            }, 5000);
          };
          
          landmarkSocket.onerror = (error) => {
            console.error('âŒ å…³é”®ç‚¹ä¼ è¾“ WebSocket é”™è¯¯:', error);
            isLandmarkSocketConnected = false;
          };
          
        } catch (error) {
          console.error('âŒ å…³é”®ç‚¹ä¼ è¾“ WebSocket åˆå§‹åŒ–å¤±è´¥:', error);
          isLandmarkSocketConnected = false;
        }
      };

      // ğŸŒ å‘é€å…³é”®ç‚¹æ•°æ®
      const sendLandmarks = (landmarks68, landmarks71) => {
        if (!isLandmarkSocketConnected || !landmarkSocket) return;
        
        try {
          landmarkSendCounter++;
          
          // æ¯3å¸§å‘é€ä¸€æ¬¡ï¼Œå‡å°‘ç½‘ç»œè´Ÿè½½
          if (landmarkSendCounter % 3 !== 0) return;
          
          const message = {
            type: 'landmarks',
            role: 'source', // æˆ‘çš„è½®å»“
            frame: landmarkSendCounter,
            timestamp: Date.now(),
            pts68: landmarks68.map(p => ({ x: p.x, y: p.y })),
            pts71: landmarks71,
            confidence: currentLandmarks ? 0.8 : 0.0 // ç®€å•çš„ç½®ä¿¡åº¦ä¼°è®¡
          };
          
          landmarkSocket.send(JSON.stringify(message));
          
          // æ¯100æ¬¡å‘é€æŠ¥å‘Šä¸€æ¬¡çŠ¶æ€
          if (landmarkSendCounter % 100 === 0) {
            console.log(`ğŸŒ å·²å‘é€ ${landmarkSendCounter} å¸§å…³é”®ç‚¹æ•°æ®åˆ°æœåŠ¡å™¨`);
          }
          
        } catch (error) {
          console.error('âŒ å‘é€å…³é”®ç‚¹æ•°æ®å¤±è´¥:', error);
        }
      };

      // åˆ›å»ºæ§åˆ¶é¢æ¿
      createColorControlPanel();
      
      // ğŸ¬ åˆå§‹åŒ–ç”»é¢åˆæˆç³»ç»Ÿ
      initCompositeSystem();
      
      // ğŸŒ åˆå§‹åŒ–å…³é”®ç‚¹ä¼ è¾“
      initLandmarkSocket();
      
      // ğŸ¯ åˆå§‹åŒ–é¢éƒ¨è¯†åˆ«ç³»ç»Ÿ (å¼‚æ­¥)
      let faceTrackingInitialized = false;
      
      const mindarThree = new MindARThree({
        container: document.querySelector("#container"),
      });
      const {renderer, scene, camera} = mindarThree;
      
      // ğŸš« ç§»é™¤å…‰ç…§ - æ”¹ä¸ºæ— å…‰ç…§æ¸²æŸ“
      // const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
      // scene.add(light);
      
      let faceMesh = null;
      if (USE_FACE_MESH_LAYER) {
        faceMesh = mindarThree.addFaceMesh();
        const texture = new THREE.TextureLoader().load('../enhanced_texture.png');
        
        // ğŸ¨ åŠ è½½é€æ˜åº¦é®ç½©è´´å›¾ (çœ¼ç›å’Œå˜´éƒ¨é€æ˜)
        const alphaTexture = new THREE.TextureLoader().load('../canonical_face_eyes.png');
        
        // ğŸ¨ ä½¿ç”¨è‡ªå®šä¹‰Shader Materialæ¥å®ç°åè½¬çš„é€æ˜åº¦é®ç½©
        const vertexShader = `
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `;
        
        const fragmentShader = `
          uniform sampler2D map;
          uniform sampler2D alphaMap;
          uniform float opacity;
          uniform vec3 color;
          varying vec2 vUv;
          
          void main() {
            vec4 texColor = texture2D(map, vUv);
            float alpha = texture2D(alphaMap, vUv).r;
            
            // ğŸ­ åè½¬Alphaé€šé“: é»‘è‰²(0)=ä¸é€æ˜(1), ç™½è‰²(1)=é€æ˜(0)
            alpha = 1.0 - alpha;
            
            // ç»“åˆæè´¨é€æ˜åº¦å’Œé®ç½©é€æ˜åº¦
            alpha = alpha * opacity;
            
            gl_FragColor = vec4(texColor.rgb * color, alpha);
          }
        `;
        
        // ğŸ¨ æ›¿æ¢ä¸ºè‡ªå®šä¹‰Shaderæè´¨å®ç°é€æ˜åº¦é®ç½©
        unlitMaterial = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: texture },
            alphaMap: { value: alphaTexture },
            opacity: { value: materialOpacity },
            color: { value: new THREE.Color(1, 1, 1) }
          },
          vertexShader: vertexShader,
          fragmentShader: fragmentShader,
          transparent: true,
          depthWrite: false,
          fog: false
        });
        
        faceMesh.material = unlitMaterial;
        
        // ä¿å­˜åŸå§‹æè´¨é¢œè‰² (Shaderæè´¨)
        originalMaterial = {
          color: unlitMaterial.uniforms.color.value.clone()
        };
        
        // ğŸ” è°ƒè¯•ä¿¡æ¯ - æ˜¾ç¤ºæè´¨ç±»å‹
        console.log('ğŸ¨ æè´¨ç±»å‹:', unlitMaterial.type);
        console.log('ğŸš« å…‰ç…§æ¨¡å¼: æ— å…‰ç…§ (ShaderMaterial)');
        console.log('ğŸ” é€æ˜åº¦æ¨¡å¼: åŠé€æ˜ + é€æ˜åº¦é®ç½© (opacity:', materialOpacity + ')');
        console.log('ğŸ­ é€æ˜åº¦é®ç½©: canonical_face_eyes.png (é»‘è‰²=ä¸é€æ˜, ç™½è‰²=é€æ˜)');
        console.log('ğŸ’¡ ç§»é™¤çš„å…‰æº: HemisphereLight');
        console.log('ğŸ¯ face-api.js é¢éƒ¨æ£€æµ‹');
      }
      
      scene.add(faceMesh);
      
      const start = async() => {
        await mindarThree.start();
        initColorSampling();
        
        // ğŸ¯ åŠ è½½ face-api.js æ¨¡å‹
        faceTrackingInitialized = await initFaceTracking();
        
        // ğŸ¯ å¯åŠ¨é¢éƒ¨è¯†åˆ«
        if (faceTrackingInitialized && mindarThree.video) {
          // ç­‰å¾…è§†é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆ
          const setupFaceTracking = () => {
            // è°ƒæ•´é¢éƒ¨ç‚¹ä½ç”»å¸ƒå°ºå¯¸
            adjustFacePointsCanvas(mindarThree.video);
            
            // åˆå§‹åŒ–1â‚¬æ»¤æ³¢å™¨
            initLandmarkFilters();
            
            const started = startFaceTracking(mindarThree.video);
            if (started) {
              updateFaceTrackingStatus('âœ… é¢éƒ¨è¯†åˆ«å·²å¯åŠ¨ (1â‚¬æ»¤æ³¢å™¨)');
            } else {
              updateFaceTrackingStatus('âŒ é¢éƒ¨è¯†åˆ«å¯åŠ¨å¤±è´¥');
            }
          };
          
          if (mindarThree.video.readyState >= 2) {
            // è§†é¢‘å·²ç»åŠ è½½å®Œæˆ
            setupFaceTracking();
          } else {
            // ç­‰å¾…è§†é¢‘åŠ è½½å®Œæˆ
            mindarThree.video.addEventListener('loadedmetadata', setupFaceTracking, { once: true });
          }
          
          // ç›‘å¬è§†é¢‘å°ºå¯¸å˜åŒ–å’Œçª—å£å¤§å°å˜åŒ–
          mindarThree.video.addEventListener('resize', () => {
            adjustFacePointsCanvas(mindarThree.video);
          });
          
          // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œé‡æ–°è°ƒæ•´ç¼©æ”¾æ¯”ä¾‹
          window.addEventListener('resize', () => {
            adjustFacePointsCanvas(mindarThree.video);
          });
        } else {
          updateFaceTrackingStatus('âŒ é¢éƒ¨è¯†åˆ«åˆå§‹åŒ–å¤±è´¥');
        }
        
        renderer.setAnimationLoop(async () => {
          // é¢œè‰²å¤„ç†ï¼ˆä»…åœ¨å¯ç”¨ FaceMesh å±‚æ—¶æ‰§è¡Œï¼‰
          if (USE_FACE_MESH_LAYER) {
            if (useAutoColor) {
              const faceColor = sampleFaceColor(mindarThree.video);
              applyColorToFaceMesh(faceMesh, faceColor, colorIntensity, colorMode);
            } else {
              applyColorToFaceMesh(faceMesh, customColor, colorIntensity, colorMode);
            }
          }
          
          // ğŸ¯ å…³é”®ç‚¹æ£€æµ‹ä¸ç»˜åˆ¶ (ä½¿ç”¨1â‚¬æ»¤æ³¢å™¨)
          if (trackingStarted && mindarThree.video.readyState >= 2) {
            const detection = await faceapi.detectSingleFace(mindarThree.video, faceDetectorOptions).withFaceLandmarks(true);
            if (detection && detection.landmarks) {
              const landmarks = detection.landmarks.positions;
              
              // è·å–å½“å‰æ—¶é—´æˆ³ï¼ˆç§’ï¼‰
              const timestamp = performance.now() / 1000;
              
              if (!currentLandmarks || !landmarkFilters) {
                // é¦–æ¬¡æ£€æµ‹ï¼šç›´æ¥è®¾ç½®å¹¶åˆå§‹åŒ–æ»¤æ³¢å™¨
                currentLandmarks = landmarks.map(pt => ({ x: pt.x, y: pt.y }));
                if (!landmarkFilters) {
                  initLandmarkFilters();
                }
              } else {
                // ä½¿ç”¨ 1â‚¬ æ»¤æ³¢å™¨å¹³æ»‘æ¯ä¸ªå…³é”®ç‚¹
                for (let i = 0; i < landmarks.length && i < landmarkFilters.length; i++) {
                  currentLandmarks[i].x = landmarkFilters[i].x.filter(landmarks[i].x, timestamp);
                  currentLandmarks[i].y = landmarkFilters[i].y.filter(landmarks[i].y, timestamp);
                }
              }
              
              // ğŸŒ è½¬æ¢ä¸º 71 ç‚¹å¹¶å‘é€åˆ° WebSocket
              if (currentLandmarks && currentLandmarks.length >= 68) {
                const landmarks71 = convert68to71(currentLandmarks);
                sendLandmarks(currentLandmarks, landmarks71);
              }
            }
            drawFacePoints();
          }
          
          // å…ˆæ¸²æŸ“åœºæ™¯
          renderer.render(scene, camera);
          
          // ğŸ¬ ç”»é¢åˆæˆï¼šåˆ›å»ºå•å±‚åˆæˆç”»é¢
          if (isCompositeEnabled && mindarThree.video) {
            const compositeFrame = createCompositeFrame(mindarThree.video, renderer, scene, camera);
            if (compositeFrame) {
              // é™åˆ¶å‘é€é¢‘ç‡ä¸º30fps
              if (colorUpdateCounter % 2 === 0) {
                sendCompositeFrame(compositeFrame);
              }
            }
          }
          
          // ğŸ¯ æ€§èƒ½ç›‘æ§å·²ç§»é™¤ï¼ˆä½¿ç”¨æµè§ˆå™¨å¼€å‘è€…å·¥å…·ä»£æ›¿ï¼‰
        });
      }
      
      // é¡µé¢å¸è½½æ—¶ä¿å­˜é…ç½®
      window.addEventListener('beforeunload', () => {
        const config = ColorPaletteManager.getCurrentConfig();
        ColorPaletteManager.saveConfig(config);
      });
      
      start();
    </script>
    <style>
      body {
        margin: 0;
        /* ğŸ¯ è®©å®¹å™¨åœ¨é¡µé¢ä¸Šå±…ä¸­ï¼Œå¹¶æä¾›ä¸€ä¸ªèƒŒæ™¯è‰² */
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100vw;
        height: 100vh;
        background-color: #111;
      }
      #container {
        /* ğŸ¯ éµå¾ª clm_video.html çš„æ–¹æ³•ï¼Œä½¿ç”¨é¢„è®¾çš„åˆå§‹æ˜¾ç¤ºå°ºå¯¸ 1280x720 */
        /* è¿™æ ·å¯ä»¥ç¡®ä¿è§†é¢‘æµå’Œå®¹å™¨çš„å®½é«˜æ¯”ä¸€è‡´ï¼Œé¿å… clmtrackr åæ ‡é”™ä½ */
        width: 1280px;
        height: 720px;
        position: relative;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div id="container">
    </div>
  </body>
</html>