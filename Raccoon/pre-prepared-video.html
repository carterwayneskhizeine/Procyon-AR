<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎬 Pre-prepared Video Stream - 合成画面显示器 + 面部形变</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            margin: 0;
        }

        #compositeCanvas {
            max-width: 100vw;
            max-height: 100vh;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #deformCanvas {
            display: none; /* 用作离屏形变渲染，不直接显示 */
        }

        #info-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            border-left: 4px solid #FFD700;
        }

        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        input[type="range"] {
            width: 200px;
        }

        button {
            background: #FFD700;
            color: #000;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin: 2px;
        }

        button:hover {
            background: #FFA500;
        }

        #status {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            z-index: 1000;
        }

        .error {
            color: #ff6b6b;
        }

        .success {
            color: #4ecdc4;
        }

        .warning {
            color: #ffa726;
        }

        /* 形变控制面板 */
        #deform-controls {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            border-left: 4px solid #00FF00;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="compositeCanvas"></canvas>
        <canvas id="deformCanvas"></canvas>
    </div>

    <div id="info-panel">
        <h3 style="margin: 0 0 10px 0; color: #FFD700;">🎬 合成画面显示器 + 🎭 面部形变</h3>
        <div><strong>状态:</strong> <span id="connectionStatus">等待连接...</span></div>
        <div><strong>分辨率:</strong> <span id="resolution">-</span></div>
        <div><strong>帧率:</strong> <span id="fps">0</span> FPS</div>
        <div><strong>数据源:</strong> <span id="dataSource">WebSocket</span></div>
        <div><strong>合成模式:</strong> <span id="compositeMode">实时合成 + 面部形变</span></div>
        <div><strong>形变状态:</strong> <span id="deformStatus">初始化中...</span></div>
    </div>

    <div id="controls">
        <h4 style="margin: 0 0 10px 0; color: #FFD700;">显示控制</h4>
        
        <div class="control-group">
            <label>画面缩放: <span id="scaleValue">100%</span></label>
            <input type="range" id="scaleSlider" min="50" max="200" value="100">
        </div>

        <div class="control-group">
            <label>亮度调节: <span id="brightnessValue">100%</span></label>
            <input type="range" id="brightnessSlider" min="50" max="150" value="100">
        </div>

        <div class="control-group">
            <label>对比度: <span id="contrastValue">100%</span></label>
            <input type="range" id="contrastSlider" min="50" max="150" value="100">
        </div>

        <div class="control-group">
            <button id="fullscreenBtn">全屏显示</button>
            <button id="saveFrameBtn">保存当前帧</button>
        </div>

        <div class="control-group">
            <button id="resetBtn">重置设置</button>
            <button id="reconnectBtn">重新连接</button>
        </div>
    </div>

    <div id="deform-controls">
        <h4 style="margin: 0 0 10px 0; color: #00FF00;">🎭 面部形变控制</h4>
        
        <div class="control-group">
            <label>
                <input type="checkbox" id="enableDeform" checked> 启用面部形变
            </label>
        </div>

        <div class="control-group">
            <label>形变强度: <span id="deformIntensityValue">100%</span></label>
            <input type="range" id="deformIntensitySlider" min="0" max="200" value="100">
        </div>

        <div class="control-group">
            <label>形变模式:</label>
            <select id="deformMode" style="width: 100%; padding: 3px; background: #333; color: white; border: 1px solid #555;">
                <option value="test">测试模式 (硬编码)</option>
                <option value="slim" selected>瘦脸模式</option>
                <option value="custom">自定义形变</option>
            </select>
        </div>

        <div class="control-group">
            <button id="testDeformBtn">测试形变</button>
            <button id="resetDeformBtn">重置形变</button>
        </div>

        <div style="font-size: 10px; color: #888; margin-top: 5px;">
            WebGL 实时面部形变 + Delaunay 三角剖分
        </div>
    </div>

    <div id="status">
        <div id="statusText">准备接收合成画面...</div>
        <div id="errorLog"></div>
    </div>

    <!-- 🎭 面部形变依赖库 -->
    <script src="../clmtrackr/examples/js/libs/utils.js"></script>
    <script src="../clmtrackr/examples/js/libs/webgl-utils.js"></script>
    <script src="../clmtrackr/build/clmtrackr.js"></script>
    <script src="../clmtrackr/models/model_pca_20_svm.js"></script>
    <script src="../clmtrackr/examples/js/face_deformer.js"></script>
    <script src="../clmtrackr/examples/js/libs/poisson_new.js"></script>

    <script>
        class CompositeVideoReceiver {
            constructor() {
                this.canvas = document.getElementById('compositeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.deformCanvas = document.getElementById('deformCanvas');
                this.websocket = null;
                this.isConnected = false;
                this.frameCount = 0;
                this.startTime = Date.now();
                this.scale = 1.0;
                this.brightness = 1.0;
                this.contrast = 1.0;
                
                // 🎭 面部形变相关
                this.faceDeformer = null;
                this.isDeformEnabled = true;
                this.deformIntensity = 1.0;
                this.deformMode = 'slim';
                this.webGLContext = null;
                this.isDeformReady = false;
                
                // 🌐 WebSocket 关键点接收相关
                this.landmarkSocket = null;
                this.isLandmarkSocketConnected = false;
                this.sourcePtsCache = null; // 我的轮廓 (来自 index-pure-texture.html)
                this.targetPtsCache = null; // 明星轮廓 (来自 index-pure-mesh.html)
                this.lastSourceFrame = 0;
                this.lastTargetFrame = 0;
                
                // ⏱️ 帧率控制
                this.lastDeformTime = 0; // 上次形变时间戳
                this.deformFrameCounter = 0; // 形变帧计数，用于降低 load 频率
                
                // 🎭 丢帧策略
                this.latestFrameData = null;   // 存放最后一帧 Blob/Base64
                this.isDecodingFrame = false; // 是否有帧正在 decode
                
                this.initializeUI();
                this.initFaceDeform();
                this.connectToSource();
                this.initLandmarkSocket();
                this.setupControls();
            }

            initializeUI() {
                // 设置画布初始尺寸
                this.canvas.width = 640;
                this.canvas.height = 480;
                this.deformCanvas.width = 640;
                this.deformCanvas.height = 480;
                
                // 显示等待画面
                this.drawWaitingScreen();
            }

            // 🎭 初始化面部形变系统
            async initFaceDeform() {
                try {
                    console.log('🎭 初始化面部形变系统...');
                    
                    // 检查 WebGL 支持
                    this.webGLContext = this.deformCanvas.getContext('webgl') || this.deformCanvas.getContext('experimental-webgl');
                    if (!this.webGLContext || !this.webGLContext.getExtension('OES_texture_float')) {
                        throw new Error('WebGL 或 OES_texture_float 扩展不支持');
                    }
                    
                    // 初始化 faceDeformer
                    if (typeof faceDeformer !== 'undefined') {
                        this.faceDeformer = new faceDeformer();
                        this.faceDeformer.init(this.deformCanvas);
                        this.isDeformReady = true;
                        console.log('✅ faceDeformer 初始化成功');
                        this.updateDeformStatus('✅ 面部形变系统就绪');
                        // 透明背景，便于与原始画面叠加
                        if (this.webGLContext) {
                            this.webGLContext.clearColor(0, 0, 0, 0);
                        }

                        // 🎯 默认使用完整 vertices 覆盖整张脸（不剪裁），确保整幅画面仅保留一层形变结果
                        this.jawVertices = null; // 传递 undefined 表示使用 pModel 全部 vertices
                        // 如需仅形变下颌外轮廓，可改为启用下方性能优化代码
                        /*
                        if (typeof pModel !== 'undefined' && pModel && pModel.path && Array.isArray(pModel.path.vertices)) {
                            const jawSet = new Set(Array.from({length:23}, (_, i) => i)); // 0-22
                            this.jawVertices = pModel.path.vertices.filter(v => jawSet.has(v[0]) && jawSet.has(v[1]) && jawSet.has(v[2]));
                            if (this.jawVertices.length === 0) {
                                console.warn('⚠️ Jaw vertices 过滤后为空，回退到全部顶点');
                                this.jawVertices = null;
                            } else {
                                console.log(`🎯 Jaw vertices 已生成: ${this.jawVertices.length} 组三角`);
                            }
                        }
                        */
                    } else {
                        throw new Error('faceDeformer 类未找到');
                    }
                    
                } catch (error) {
                    console.error('❌ 面部形变初始化失败:', error);
                    this.updateDeformStatus('❌ 面部形变初始化失败: ' + error.message);
                    this.isDeformReady = false;
                }
            }

            // 🎭 硬编码测试点位数据
            getTestPoints() {
                // 硬编码的 71 个面部关键点 (标准脸型)
                const sourcePoints = [
                    // 脸部轮廓 0-14
                    [150, 180], [160, 190], [170, 200], [180, 210], [190, 220],
                    [200, 230], [210, 240], [220, 250], [230, 240], [240, 230],
                    [250, 220], [260, 210], [270, 200], [280, 190], [290, 180],
                    
                    // 右眉 15-18
                    [170, 160], [180, 155], [190, 155], [200, 160],
                    
                    // 左眉 19-22  
                    [240, 160], [250, 155], [260, 155], [270, 160],
                    
                    // 左眼外圈 23-26
                    [180, 170], [190, 165], [200, 170], [190, 175],
                    
                    // 左眼中心 27
                    [190, 170],
                    
                    // 右眼外圈 28-31
                    [250, 170], [240, 165], [250, 175], [260, 170],
                    
                    // 右眼中心 32
                    [250, 170],
                    
                    // 鼻子区域 33-43
                    [220, 150], [210, 180], [215, 185], [220, 190], [225, 185],
                    [230, 180], [225, 195], [220, 200], [215, 195], [220, 205],
                    [220, 185],
                    
                    // 嘴巴外轮廓 44-55
                    [200, 220], [205, 225], [210, 228], [215, 230], [220, 230], [225, 230],
                    [230, 230], [235, 228], [240, 225], [235, 235], [230, 240], [225, 240],
                    
                    // 嘴巴内轮廓 56-61
                    [210, 230], [215, 232], [220, 232], [225, 232], [230, 230], [220, 235],
                    
                    // 鼻尖上方 62
                    [220, 180],
                    
                    // 左眼下方额外点 63-66
                    [185, 175], [195, 180], [205, 175], [200, 180],
                    
                    // 右眼下方额外点 67-70
                    [235, 175], [245, 180], [255, 175], [250, 180]
                ];

                // 目标点位（瘦脸效果：收窄脸部轮廓）
                const targetPoints = sourcePoints.map((point, index) => {
                    let [x, y] = point;
                    
                    // 对脸部轮廓进行瘦脸处理
                    if (index <= 14) { // 脸部轮廓点 (0-14)
                        const centerX = 220; // 脸部中心X坐标
                        
                        // 根据不同区域使用不同的收窄系数
                        let factor;
                        if (index <= 4 || index >= 12) {
                            // 脸颊区域 - 更强的收窄
                            factor = 0.6;
                        } else if (index <= 8) {
                            // 下颌区域 - 中等收窄
                            factor = 0.75;
                        } else {
                            // 其他区域 - 轻微收窄
                            factor = 0.85;
                        }
                        
                        x = centerX + (x - centerX) * factor;
                    }
                    
                    return [x, y];
                });

                return { sourcePoints, targetPoints };
            }

            // 🌐 初始化关键点接收 WebSocket
            initLandmarkSocket() {
                try {
                    console.log('🌐 连接关键点接收服务器...');
                    this.landmarkSocket = new WebSocket('ws://localhost:3003?type=receiver');
                    
                    this.landmarkSocket.onopen = () => {
                        console.log('✅ 关键点接收 WebSocket 连接成功');
                        this.isLandmarkSocketConnected = true;
                        this.updateDeformStatus('✅ 面部形变系统就绪 + WebSocket连接成功');
                    };
                    
                    this.landmarkSocket.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            
                            if (message.type === 'landmarks') {
                                if (message.role === 'source') {
                                    // 接收我的轮廓数据
                                    this.sourcePtsCache = message.pts71;
                                    this.lastSourceFrame = message.frame || Date.now();
                                    
                                    console.log(`🌐 接收 source 轮廓: ${this.sourcePtsCache.length} 个点 (frame: ${this.lastSourceFrame})`);
                                } else if (message.role === 'target') {
                                    // 接收明星轮廓数据
                                    this.targetPtsCache = message.pts71;
                                    this.lastTargetFrame = message.frame || Date.now();
                                    
                                    console.log(`🌐 接收 target 轮廓: ${this.targetPtsCache.length} 个点 (frame: ${this.lastTargetFrame})`);
                                }
                                
                                // 更新状态显示
                                const status = `source: ${this.sourcePtsCache ? '✅' : '❌'} | target: ${this.targetPtsCache ? '✅' : '❌'}`;
                                this.updateDeformStatus(`🌐 实时数据: ${status}`);
                            } else if (message.type === 'welcome') {
                                console.log('🌐 收到欢迎消息:', message.message);
                            }
                            
                        } catch (error) {
                            console.warn('⚠️ 关键点 WebSocket 消息解析失败:', error);
                        }
                    };
                    
                    this.landmarkSocket.onclose = () => {
                        console.log('❌ 关键点接收 WebSocket 连接断开');
                        this.isLandmarkSocketConnected = false;
                        this.updateDeformStatus('⚠️ 形变系统运行中，WebSocket已断开');
                        
                        // 5秒后尝试重连
                        setTimeout(() => {
                            if (!this.isLandmarkSocketConnected) {
                                this.initLandmarkSocket();
                            }
                        }, 5000);
                    };
                    
                    this.landmarkSocket.onerror = (error) => {
                        console.error('❌ 关键点接收 WebSocket 错误:', error);
                        this.isLandmarkSocketConnected = false;
                    };
                    
                } catch (error) {
                    console.error('❌ 关键点接收 WebSocket 初始化失败:', error);
                    this.isLandmarkSocketConnected = false;
                }
            }

            // 🎭 执行面部形变
            performFaceDeform(sourceImage) {
                if (!this.isDeformReady || !this.isDeformEnabled || !this.faceDeformer) {
                    return sourceImage;
                }

                try {
                    let sourcePoints, targetPoints;
                    
                    // 🌐 使用实时数据进行形变 (支持 test 和 slim 模式)
                    if (this.sourcePtsCache && (this.deformMode === 'test' || this.deformMode === 'slim')) {
                        // 使用实时接收的我的轮廓作为 source
                        sourcePoints = this.sourcePtsCache;
                        
                        // 生成瘦脸目标点 (对轮廓进行收窄)
                        targetPoints = sourcePoints.map((point, index) => {
                            let [x, y] = point;
                            
                            // 对脸部轮廓进行瘦脸处理
                            if (index <= 14) { // 脸部轮廓点 (0-14)
                                // 使用面部中心作为基准点
                                const leftCheek = sourcePoints[0] ? sourcePoints[0][0] : x;
                                const rightCheek = sourcePoints[14] ? sourcePoints[14][0] : x;
                                const centerX = (leftCheek + rightCheek) / 2;
                                
                                // 根据不同区域使用不同的收窄系数
                                let factor;
                                if (index <= 4 || index >= 12) {
                                    // 脸颊区域 - 更强的收窄
                                    factor = 0.6;
                                } else if (index <= 8) {
                                    // 下颌区域 - 中等收窄
                                    factor = 0.75;
                                } else {
                                    // 其他区域 - 轻微收窄
                                    factor = 0.85;
                                }
                                
                                x = centerX + (x - centerX) * factor;
                            }
                            
                            return [x, y];
                        });
                        
                        // 计算瘦脸效果统计
                        const faceWidth = Math.abs(sourcePoints[14][0] - sourcePoints[0][0]);
                        const targetWidth = Math.abs(targetPoints[14][0] - targetPoints[0][0]);
                        const slimmingRate = ((faceWidth - targetWidth) / faceWidth * 100).toFixed(1);
                        
                        console.log(`🌐 使用实时 source 数据进行形变 - 瘦脸效果: ${slimmingRate}%`);
                    } else {
                        // 回退到硬编码测试数据
                        const testData = this.getTestPoints();
                        sourcePoints = testData.sourcePoints;
                        targetPoints = testData.targetPoints;
                        
                        console.log('🔄 使用硬编码测试数据进行形变');
                    }
                    
                    // const vertices = this.getVertices();
                    
                    // 应用形变强度
                    let interpolatedPoints = sourcePoints.map((sourcePoint, index) => {
                        const targetPoint = targetPoints[index];
                        return [
                            sourcePoint[0] + (targetPoint[0] - sourcePoint[0]) * this.deformIntensity,
                            sourcePoint[1] + (targetPoint[1] - sourcePoint[1]) * this.deformIntensity
                        ];
                    });

                    // 创建临时画布
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = sourceImage.width || this.canvas.width;
                    tempCanvas.height = sourceImage.height || this.canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // 绘制源图像到临时画布
                    if (sourceImage instanceof HTMLImageElement || sourceImage instanceof HTMLCanvasElement) {
                        tempCtx.drawImage(sourceImage, 0, 0, tempCanvas.width, tempCanvas.height);
                    } else {
                        console.warn('⚠️ 源图像格式不支持，跳过形变');
                        return sourceImage;
                    }

                    // === 生成扩展点与三角形 ===
                    // 参照 clmtrackr facedeform 示例：在脸部周围添加 23 个放大点，索引 71-93
                    const centerIdx = 62; // 以鼻尖上方点为中心
                    if (sourcePoints.length >= 63) {
                        let addPos = [];
                        for (let i = 0; i < 23; i++) {
                            const base = sourcePoints[i];
                            const center = sourcePoints[centerIdx];
                            const newX = (base[0] - center[0]) * 1.3 + center[0];
                            const newY = (base[1] - center[1]) * 1.3 + center[1];
                            addPos.push([newX, newY]);
                        }
                        const newPos = sourcePoints.concat(addPos); // 94 个点

                        // 复制 pModel 原有三角并拼接扩展三角
                        const extendVertices = [
                            [0,71,72,0],[0,72,1,0],[1,72,73,1],[1,73,2,1],[2,73,74,2],[2,74,3,2],
                            [3,74,75,3],[3,75,4,3],[4,75,76,4],[4,76,5,4],[5,76,77,5],[5,77,6,5],
                            [6,77,78,6],[6,78,7,6],[7,78,79,7],[7,79,8,7],[8,79,80,8],[8,80,9,8],
                            [9,80,81,9],[9,81,10,9],[10,81,82,10],[10,82,11,10],[11,82,83,11],
                            [11,83,12,11],[12,83,84,12],[12,84,13,12],[13,84,85,13],[13,85,14,13],
                            [14,85,86,14],[14,86,15,14],[15,86,87,15],[15,87,16,15],[16,87,88,16],
                            [16,88,17,16],[17,88,89,17],[17,89,18,17],[18,89,93,18],[18,93,22,18],
                            [22,93,21,22],[93,92,21,93],[21,92,20,21],[92,91,20,92],[20,91,19,20],
                            [91,90,19,91],[19,90,71,19],[19,71,0,19]
                        ];

                        const newVertices = (pModel.path && pModel.path.vertices) ? pModel.path.vertices.concat(extendVertices) : extendVertices;

                        // 每3帧才重新加载纹理，其他帧仅 draw
                        if (this.deformFrameCounter % 3 === 0) {
                            this.faceDeformer.load(tempCanvas, newPos, pModel, newVertices);
                        }

                        // 补全 interpolatedPoints 与 newPos 一致
                        interpolatedPoints = interpolatedPoints.concat(addPos);
                    } else {
                        // 回退：使用原始 vertices
                        this.faceDeformer.load(tempCanvas, sourcePoints, pModel, this.jawVertices || undefined);
                    }
                    
                    // 🎨 先绘制完整背景到 deformCanvas，再执行形变
                    const deformCtx = this.deformCanvas.getContext('2d');
                    if (deformCtx) {
                        // 清空并绘制完整的原始画面作为背景
                        deformCtx.clearRect(0, 0, this.deformCanvas.width, this.deformCanvas.height);
                        deformCtx.drawImage(sourceImage, 0, 0, this.deformCanvas.width, this.deformCanvas.height);
                    }
                    
                    // 设置 WebGL 透明背景，让形变结果叠加在背景上
                    if (this.webGLContext) {
                        this.webGLContext.clearColor(0, 0, 0, 0); // 透明背景
                        this.webGLContext.clear(this.webGLContext.COLOR_BUFFER_BIT);
                    }

                    // ⏱️ 帧率丢帧逻辑：限制到 ~20 FPS (>=50ms)
                    const now = performance.now();
                    if (now - this.lastDeformTime >= 50) {
                        this.deformFrameCounter++;
                        this.faceDeformer.draw(interpolatedPoints);
                        this.lastDeformTime = now;
                    }
                    
                    return this.deformCanvas;
                    
                } catch (error) {
                    console.error('❌ 面部形变执行失败:', error);
                    this.updateDeformStatus('❌ 形变失败: ' + error.message);
                    return sourceImage;
                }
            }

            drawWaitingScreen() {
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.fillStyle = '#FFD700';
                this.ctx.font = '24px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('🎬 等待合成画面...', this.canvas.width / 2, this.canvas.height / 2 - 20);
                
                this.ctx.fillStyle = '#888';
                this.ctx.font = '14px Arial';
                this.ctx.fillText('🎭 面部形变系统已启用', this.canvas.width / 2, this.canvas.height / 2 + 20);
            }

            connectToSource() {
                try {
                    // 连接到 WebSocket 服务器接收合成画面
                    this.websocket = new WebSocket('ws://localhost:3002?type=receiver');
                    
                    this.websocket.onopen = () => {
                        console.log('✅ WebSocket 连接成功');
                        this.isConnected = true;
                        this.updateStatus('已连接', 'success');
                        document.getElementById('connectionStatus').textContent = '已连接';
                        document.getElementById('connectionStatus').className = 'success';
                    };

                    // 🎭 丢帧：始终只保留最新一帧
                    this.websocket.onmessage = (event) => {
                        this.latestFrameData = event.data;
                        // 如果当前没有在解码，则立即处理
                        if (!this.isDecodingFrame) {
                            this.decodeAndDrawLatestFrame();
                        }
                    };

                    this.websocket.onclose = () => {
                        console.log('❌ WebSocket 连接断开');
                        this.isConnected = false;
                        this.updateStatus('连接断开', 'error');
                        document.getElementById('connectionStatus').textContent = '连接断开';
                        document.getElementById('connectionStatus').className = 'error';
                        
                        // 5秒后自动重连
                        setTimeout(() => {
                            if (!this.isConnected) {
                                this.connectToSource();
                            }
                        }, 5000);
                    };

                    this.websocket.onerror = (error) => {
                        console.error('❌ WebSocket 错误:', error);
                        this.updateStatus('连接错误', 'error');
                    };

                } catch (error) {
                    console.error('❌ 连接失败:', error);
                    this.updateStatus('连接失败: ' + error.message, 'error');
                    
                    // 备用方案：使用 HTTP 轮询
                    this.startHttpPolling();
                }
            }

            startHttpPolling() {
                console.log('🔄 启动 HTTP 轮询模式...');
                this.updateStatus('HTTP 轮询模式暂不可用', 'warning');
                
                // 注意：由于删除了 face-landmarks-server.cjs，HTTP API 不再可用
                // 请确保 WebSocket 服务器正在运行以接收合成画面
                console.warn('⚠️ HTTP API 不可用，请使用 WebSocket 连接');
            }

            // 🎭 解码并绘制最新帧（丢弃过期帧）
            decodeAndDrawLatestFrame() {
                const data = this.latestFrameData;
                if (!data) return;
                this.isDecodingFrame = true;

                const img = new Image();
                img.onload = () => {
                    this.isDecodingFrame = false;
                    this.handleCompositeFrameDecoded(img);
                    // 如果在解码期间新帧又来了，再次处理
                    if (this.latestFrameData !== data) {
                        this.decodeAndDrawLatestFrame();
                    }
                };
                img.onerror = (err) => {
                    console.error('❌ 图片解码失败:', err);
                    this.updateStatus('图片解码失败', 'error');
                    this.isDecodingFrame = false;
                };

                if (data instanceof Blob) {
                    img.src = URL.createObjectURL(data);
                } else if (typeof data === 'string') {
                    img.src = data;
                }
            }

            // 🎭 原 handleCompositeFrame 逻辑拆分为绘制解码后 img
            handleCompositeFrameDecoded(img) {
                try {
                    if (!img) return;
                    // 更新尺寸等 (与旧逻辑一致)
                    if (this.canvas.width !== img.width || this.canvas.height !== img.height) {
                        this.canvas.width = img.width;
                        this.canvas.height = img.height;
                        this.deformCanvas.width = img.width;
                        this.deformCanvas.height = img.height;
                        document.getElementById('resolution').textContent = `${img.width}x${img.height}`;
                    }

                    // 🎭 形变
                    let hasDeform = false;
                    if (this.isDeformEnabled && this.isDeformReady) {
                        this.performFaceDeform(img);
                        hasDeform = true;
                    }

                    // 绘制
                    let canvasWidth = img.width * this.scale;
                    let canvasHeight = img.height * this.scale;
                    this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                    this.ctx.filter = `brightness(${this.brightness}) contrast(${this.contrast})`;
                    this.ctx.save();
                    this.ctx.scale(-1, 1);
                    this.ctx.translate(-canvasWidth, 0);
                    this.ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                    if (hasDeform) {
                        this.ctx.drawImage(this.deformCanvas, 0, 0, canvasWidth, canvasHeight);
                    }
                    this.ctx.restore();
                    this.ctx.filter = 'none';
                    this.updateFrameRate();
                } catch (error) {
                    console.error('❌ 绘制帧失败:', error);
                    this.updateStatus('绘制帧失败: ' + error.message, 'error');
                }
            }

            updateFrameRate() {
                this.frameCount++;
                const currentTime = Date.now();
                const elapsed = (currentTime - this.startTime) / 1000;
                
                if (elapsed >= 1) {
                    const fps = Math.round(this.frameCount / elapsed);
                    document.getElementById('fps').textContent = fps;
                    
                    // 重置计数器
                    this.frameCount = 0;
                    this.startTime = currentTime;
                }
            }

            // 🎭 更新形变状态显示
            updateDeformStatus(status) {
                const statusElement = document.getElementById('deformStatus');
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }

            setupControls() {
                // 缩放控制
                const scaleSlider = document.getElementById('scaleSlider');
                const scaleValue = document.getElementById('scaleValue');
                
                scaleSlider.addEventListener('input', (e) => {
                    this.scale = e.target.value / 100;
                    scaleValue.textContent = e.target.value + '%';
                });

                // 亮度控制
                const brightnessSlider = document.getElementById('brightnessSlider');
                const brightnessValue = document.getElementById('brightnessValue');
                
                brightnessSlider.addEventListener('input', (e) => {
                    this.brightness = e.target.value / 100;
                    brightnessValue.textContent = e.target.value + '%';
                });

                // 对比度控制
                const contrastSlider = document.getElementById('contrastSlider');
                const contrastValue = document.getElementById('contrastValue');
                
                contrastSlider.addEventListener('input', (e) => {
                    this.contrast = e.target.value / 100;
                    contrastValue.textContent = e.target.value + '%';
                });

                // 🎭 面部形变控制
                const enableDeform = document.getElementById('enableDeform');
                const deformIntensitySlider = document.getElementById('deformIntensitySlider');
                const deformIntensityValue = document.getElementById('deformIntensityValue');
                const deformMode = document.getElementById('deformMode');
                const testDeformBtn = document.getElementById('testDeformBtn');
                const resetDeformBtn = document.getElementById('resetDeformBtn');

                enableDeform.addEventListener('change', (e) => {
                    this.isDeformEnabled = e.target.checked;
                    this.updateDeformStatus(this.isDeformEnabled ? '✅ 形变已启用' : '⏸️ 形变已暂停');
                });

                deformIntensitySlider.addEventListener('input', (e) => {
                    this.deformIntensity = e.target.value / 100;
                    deformIntensityValue.textContent = e.target.value + '%';
                });

                deformMode.addEventListener('change', (e) => {
                    this.deformMode = e.target.value;
                    this.updateDeformStatus(`模式已切换: ${e.target.value}`);
                });

                testDeformBtn.addEventListener('click', () => {
                    this.testDeformation();
                });

                resetDeformBtn.addEventListener('click', () => {
                    this.resetDeformation();
                });

                // 全屏按钮
                document.getElementById('fullscreenBtn').addEventListener('click', () => {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.documentElement.requestFullscreen();
                    }
                });

                // 保存当前帧
                document.getElementById('saveFrameBtn').addEventListener('click', () => {
                    this.saveCurrentFrame();
                });

                // 重置设置
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetSettings();
                });

                // 重新连接
                document.getElementById('reconnectBtn').addEventListener('click', () => {
                    this.reconnect();
                });
            }

            // 🎭 测试形变功能
            testDeformation() {
                if (!this.isDeformReady) {
                    this.updateDeformStatus('❌ 形变系统未就绪');
                    return;
                }

                try {
                    // 创建测试图像
                    const testCanvas = document.createElement('canvas');
                    testCanvas.width = 640;
                    testCanvas.height = 480;
                    const testCtx = testCanvas.getContext('2d');
                    
                    // 绘制测试图像
                    testCtx.fillStyle = '#f0f0f0';
                    testCtx.fillRect(0, 0, 640, 480);
                    testCtx.fillStyle = '#333';
                    testCtx.font = '30px Arial';
                    testCtx.textAlign = 'center';
                    testCtx.fillText('🎭 形变测试', 320, 240);
                    
                    // 执行形变
                    const result = this.performFaceDeform(testCanvas);
                    this.updateDeformStatus('✅ 形变测试完成');
                    
                } catch (error) {
                    console.error('❌ 形变测试失败:', error);
                    this.updateDeformStatus('❌ 形变测试失败: ' + error.message);
                }
            }

            // 🎭 重置形变
            resetDeformation() {
                this.deformIntensity = 1.0;
                document.getElementById('deformIntensitySlider').value = 100;
                document.getElementById('deformIntensityValue').textContent = '100%';
                this.updateDeformStatus('🔄 形变参数已重置');
            }

            saveCurrentFrame() {
                try {
                    const activeCanvas = this.isDeformEnabled && this.isDeformReady ? this.deformCanvas : this.canvas;
                    const link = document.createElement('a');
                    link.download = `composite-frame-${Date.now()}.png`;
                    link.href = activeCanvas.toDataURL();
                    link.click();
                    
                    this.updateStatus('当前帧已保存', 'success');
                } catch (error) {
                    console.error('❌ 保存失败:', error);
                    this.updateStatus('保存失败: ' + error.message, 'error');
                }
            }

            resetSettings() {
                this.scale = 1.0;
                this.brightness = 1.0;
                this.contrast = 1.0;
                
                document.getElementById('scaleSlider').value = 100;
                document.getElementById('scaleValue').textContent = '100%';
                document.getElementById('brightnessSlider').value = 100;
                document.getElementById('brightnessValue').textContent = '100%';
                document.getElementById('contrastSlider').value = 100;
                document.getElementById('contrastValue').textContent = '100%';
                
                this.updateStatus('设置已重置', 'success');
            }

            reconnect() {
                if (this.websocket) {
                    this.websocket.close();
                }
                this.updateStatus('正在重新连接...', 'warning');
                setTimeout(() => {
                    this.connectToSource();
                }, 1000);
            }

            updateStatus(message, type = 'info') {
                const statusText = document.getElementById('statusText');
                statusText.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                statusText.className = type;
                
                console.log(`📊 [${type.toUpperCase()}] ${message}`);
            }
        }

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🎬 合成画面显示器 + 🎭 面部形变系统已启动');
            const receiver = new CompositeVideoReceiver();
            
            // 全局错误处理
            window.addEventListener('error', (error) => {
                console.error('❌ 全局错误:', error);
                receiver.updateStatus('系统错误: ' + error.message, 'error');
            });

            // 页面可见性变化处理
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    console.log('📴 页面隐藏，暂停接收');
                } else {
                    console.log('📺 页面显示，恢复接收');
                    receiver.reconnect();
                }
            });

            // 窗口大小变化处理
            window.addEventListener('resize', () => {
                // 触发画面重新调整（如果有当前画面的话）
                console.log('📐 窗口大小已改变，重新调整画面尺寸');
            });
        });
    </script>
</body>
</html> 