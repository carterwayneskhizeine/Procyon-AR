<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ¬ Pre-prepared Video Stream - åˆæˆç”»é¢æ˜¾ç¤ºå™¨ + é¢éƒ¨å½¢å˜</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            margin: 0;
        }

        #compositeCanvas {
            max-width: 100vw;
            max-height: 100vh;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #deformCanvas {
            display: none; /* ç”¨ä½œç¦»å±å½¢å˜æ¸²æŸ“ï¼Œä¸ç›´æ¥æ˜¾ç¤º */
        }

        #info-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            border-left: 4px solid #FFD700;
        }

        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        input[type="range"] {
            width: 200px;
        }

        button {
            background: #FFD700;
            color: #000;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin: 2px;
        }

        button:hover {
            background: #FFA500;
        }

        #status {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 11px;
            z-index: 1000;
        }

        .error {
            color: #ff6b6b;
        }

        .success {
            color: #4ecdc4;
        }

        .warning {
            color: #ffa726;
        }

        /* å½¢å˜æ§åˆ¶é¢æ¿ */
        #deform-controls {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            border-left: 4px solid #00FF00;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="compositeCanvas"></canvas>
        <canvas id="deformCanvas"></canvas>
    </div>

    <div id="info-panel">
        <h3 style="margin: 0 0 10px 0; color: #FFD700;">ğŸ¬ åˆæˆç”»é¢æ˜¾ç¤ºå™¨ + ğŸ­ é¢éƒ¨å½¢å˜</h3>
        <div><strong>çŠ¶æ€:</strong> <span id="connectionStatus">ç­‰å¾…è¿æ¥...</span></div>
        <div><strong>åˆ†è¾¨ç‡:</strong> <span id="resolution">-</span></div>
        <div><strong>å¸§ç‡:</strong> <span id="fps">0</span> FPS</div>
        <div><strong>æ•°æ®æº:</strong> <span id="dataSource">WebSocket</span></div>
        <div><strong>åˆæˆæ¨¡å¼:</strong> <span id="compositeMode">å®æ—¶åˆæˆ + é¢éƒ¨å½¢å˜</span></div>
        <div><strong>å½¢å˜çŠ¶æ€:</strong> <span id="deformStatus">åˆå§‹åŒ–ä¸­...</span></div>
    </div>

    <div id="controls">
        <h4 style="margin: 0 0 10px 0; color: #FFD700;">æ˜¾ç¤ºæ§åˆ¶</h4>
        
        <div class="control-group">
            <label>ç”»é¢ç¼©æ”¾: <span id="scaleValue">100%</span></label>
            <input type="range" id="scaleSlider" min="50" max="200" value="100">
        </div>

        <div class="control-group">
            <label>äº®åº¦è°ƒèŠ‚: <span id="brightnessValue">100%</span></label>
            <input type="range" id="brightnessSlider" min="50" max="150" value="100">
        </div>

        <div class="control-group">
            <label>å¯¹æ¯”åº¦: <span id="contrastValue">100%</span></label>
            <input type="range" id="contrastSlider" min="50" max="150" value="100">
        </div>

        <div class="control-group">
            <button id="fullscreenBtn">å…¨å±æ˜¾ç¤º</button>
            <button id="saveFrameBtn">ä¿å­˜å½“å‰å¸§</button>
        </div>

        <div class="control-group">
            <button id="resetBtn">é‡ç½®è®¾ç½®</button>
            <button id="reconnectBtn">é‡æ–°è¿æ¥</button>
        </div>
    </div>

    <div id="deform-controls">
        <h4 style="margin: 0 0 10px 0; color: #00FF00;">ğŸ­ é¢éƒ¨å½¢å˜æ§åˆ¶</h4>
        
        <div class="control-group">
            <label>
                <input type="checkbox" id="enableDeform" checked> å¯ç”¨é¢éƒ¨å½¢å˜
            </label>
        </div>

        <div class="control-group">
            <label>å½¢å˜å¼ºåº¦: <span id="deformIntensityValue">100%</span></label>
            <input type="range" id="deformIntensitySlider" min="0" max="200" value="100">
        </div>

        <div class="control-group">
            <label>å½¢å˜æ¨¡å¼:</label>
            <select id="deformMode" style="width: 100%; padding: 3px; background: #333; color: white; border: 1px solid #555;">
                <option value="test">æµ‹è¯•æ¨¡å¼ (ç¡¬ç¼–ç )</option>
                <option value="slim" selected>ç˜¦è„¸æ¨¡å¼</option>
                <option value="custom">è‡ªå®šä¹‰å½¢å˜</option>
            </select>
        </div>

        <div class="control-group">
            <button id="testDeformBtn">æµ‹è¯•å½¢å˜</button>
            <button id="resetDeformBtn">é‡ç½®å½¢å˜</button>
        </div>

        <div style="font-size: 10px; color: #888; margin-top: 5px;">
            WebGL å®æ—¶é¢éƒ¨å½¢å˜ + Delaunay ä¸‰è§’å‰–åˆ†
        </div>
    </div>

    <div id="status">
        <div id="statusText">å‡†å¤‡æ¥æ”¶åˆæˆç”»é¢...</div>
        <div id="errorLog"></div>
    </div>

    <!-- ğŸ­ é¢éƒ¨å½¢å˜ä¾èµ–åº“ -->
    <script src="../clmtrackr/examples/js/libs/utils.js"></script>
    <script src="../clmtrackr/examples/js/libs/webgl-utils.js"></script>
    <script src="../clmtrackr/build/clmtrackr.js"></script>
    <script src="../clmtrackr/models/model_pca_20_svm.js"></script>
    <script src="../clmtrackr/examples/js/face_deformer.js"></script>
    <script src="../clmtrackr/examples/js/libs/poisson_new.js"></script>

    <script>
        class CompositeVideoReceiver {
            constructor() {
                this.canvas = document.getElementById('compositeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.deformCanvas = document.getElementById('deformCanvas');
                this.websocket = null;
                this.isConnected = false;
                this.frameCount = 0;
                this.startTime = Date.now();
                this.scale = 1.0;
                this.brightness = 1.0;
                this.contrast = 1.0;
                
                // ğŸ­ é¢éƒ¨å½¢å˜ç›¸å…³
                this.faceDeformer = null;
                this.isDeformEnabled = true;
                this.deformIntensity = 1.0;
                this.deformMode = 'slim';
                this.webGLContext = null;
                this.isDeformReady = false;
                
                // ğŸŒ WebSocket å…³é”®ç‚¹æ¥æ”¶ç›¸å…³
                this.landmarkSocket = null;
                this.isLandmarkSocketConnected = false;
                this.sourcePtsCache = null; // æˆ‘çš„è½®å»“ (æ¥è‡ª index-pure-texture.html)
                this.targetPtsCache = null; // æ˜æ˜Ÿè½®å»“ (æ¥è‡ª index-pure-mesh.html)
                this.lastSourceFrame = 0;
                this.lastTargetFrame = 0;
                
                // â±ï¸ å¸§ç‡æ§åˆ¶
                this.lastDeformTime = 0; // ä¸Šæ¬¡å½¢å˜æ—¶é—´æˆ³
                this.deformFrameCounter = 0; // å½¢å˜å¸§è®¡æ•°ï¼Œç”¨äºé™ä½ load é¢‘ç‡
                
                // ğŸ­ ä¸¢å¸§ç­–ç•¥
                this.latestFrameData = null;   // å­˜æ”¾æœ€åä¸€å¸§ Blob/Base64
                this.isDecodingFrame = false; // æ˜¯å¦æœ‰å¸§æ­£åœ¨ decode
                
                this.initializeUI();
                this.initFaceDeform();
                this.connectToSource();
                this.initLandmarkSocket();
                this.setupControls();
            }

            initializeUI() {
                // è®¾ç½®ç”»å¸ƒåˆå§‹å°ºå¯¸
                this.canvas.width = 640;
                this.canvas.height = 480;
                this.deformCanvas.width = 640;
                this.deformCanvas.height = 480;
                
                // æ˜¾ç¤ºç­‰å¾…ç”»é¢
                this.drawWaitingScreen();
            }

            // ğŸ­ åˆå§‹åŒ–é¢éƒ¨å½¢å˜ç³»ç»Ÿ
            async initFaceDeform() {
                try {
                    console.log('ğŸ­ åˆå§‹åŒ–é¢éƒ¨å½¢å˜ç³»ç»Ÿ...');
                    
                    // æ£€æŸ¥ WebGL æ”¯æŒ
                    this.webGLContext = this.deformCanvas.getContext('webgl') || this.deformCanvas.getContext('experimental-webgl');
                    if (!this.webGLContext || !this.webGLContext.getExtension('OES_texture_float')) {
                        throw new Error('WebGL æˆ– OES_texture_float æ‰©å±•ä¸æ”¯æŒ');
                    }
                    
                    // åˆå§‹åŒ– faceDeformer
                    if (typeof faceDeformer !== 'undefined') {
                        this.faceDeformer = new faceDeformer();
                        this.faceDeformer.init(this.deformCanvas);
                        this.isDeformReady = true;
                        console.log('âœ… faceDeformer åˆå§‹åŒ–æˆåŠŸ');
                        this.updateDeformStatus('âœ… é¢éƒ¨å½¢å˜ç³»ç»Ÿå°±ç»ª');
                        // é€æ˜èƒŒæ™¯ï¼Œä¾¿äºä¸åŸå§‹ç”»é¢å åŠ 
                        if (this.webGLContext) {
                            this.webGLContext.clearColor(0, 0, 0, 0);
                        }

                        // ğŸ¯ é»˜è®¤ä½¿ç”¨å®Œæ•´ vertices è¦†ç›–æ•´å¼ è„¸ï¼ˆä¸å‰ªè£ï¼‰ï¼Œç¡®ä¿æ•´å¹…ç”»é¢ä»…ä¿ç•™ä¸€å±‚å½¢å˜ç»“æœ
                        this.jawVertices = null; // ä¼ é€’ undefined è¡¨ç¤ºä½¿ç”¨ pModel å…¨éƒ¨ vertices
                        // å¦‚éœ€ä»…å½¢å˜ä¸‹é¢Œå¤–è½®å»“ï¼Œå¯æ”¹ä¸ºå¯ç”¨ä¸‹æ–¹æ€§èƒ½ä¼˜åŒ–ä»£ç 
                        /*
                        if (typeof pModel !== 'undefined' && pModel && pModel.path && Array.isArray(pModel.path.vertices)) {
                            const jawSet = new Set(Array.from({length:23}, (_, i) => i)); // 0-22
                            this.jawVertices = pModel.path.vertices.filter(v => jawSet.has(v[0]) && jawSet.has(v[1]) && jawSet.has(v[2]));
                            if (this.jawVertices.length === 0) {
                                console.warn('âš ï¸ Jaw vertices è¿‡æ»¤åä¸ºç©ºï¼Œå›é€€åˆ°å…¨éƒ¨é¡¶ç‚¹');
                                this.jawVertices = null;
                            } else {
                                console.log(`ğŸ¯ Jaw vertices å·²ç”Ÿæˆ: ${this.jawVertices.length} ç»„ä¸‰è§’`);
                            }
                        }
                        */
                    } else {
                        throw new Error('faceDeformer ç±»æœªæ‰¾åˆ°');
                    }
                    
                } catch (error) {
                    console.error('âŒ é¢éƒ¨å½¢å˜åˆå§‹åŒ–å¤±è´¥:', error);
                    this.updateDeformStatus('âŒ é¢éƒ¨å½¢å˜åˆå§‹åŒ–å¤±è´¥: ' + error.message);
                    this.isDeformReady = false;
                }
            }

            // ğŸ­ ç¡¬ç¼–ç æµ‹è¯•ç‚¹ä½æ•°æ®
            getTestPoints() {
                // ç¡¬ç¼–ç çš„ 71 ä¸ªé¢éƒ¨å…³é”®ç‚¹ (æ ‡å‡†è„¸å‹)
                const sourcePoints = [
                    // è„¸éƒ¨è½®å»“ 0-14
                    [150, 180], [160, 190], [170, 200], [180, 210], [190, 220],
                    [200, 230], [210, 240], [220, 250], [230, 240], [240, 230],
                    [250, 220], [260, 210], [270, 200], [280, 190], [290, 180],
                    
                    // å³çœ‰ 15-18
                    [170, 160], [180, 155], [190, 155], [200, 160],
                    
                    // å·¦çœ‰ 19-22  
                    [240, 160], [250, 155], [260, 155], [270, 160],
                    
                    // å·¦çœ¼å¤–åœˆ 23-26
                    [180, 170], [190, 165], [200, 170], [190, 175],
                    
                    // å·¦çœ¼ä¸­å¿ƒ 27
                    [190, 170],
                    
                    // å³çœ¼å¤–åœˆ 28-31
                    [250, 170], [240, 165], [250, 175], [260, 170],
                    
                    // å³çœ¼ä¸­å¿ƒ 32
                    [250, 170],
                    
                    // é¼»å­åŒºåŸŸ 33-43
                    [220, 150], [210, 180], [215, 185], [220, 190], [225, 185],
                    [230, 180], [225, 195], [220, 200], [215, 195], [220, 205],
                    [220, 185],
                    
                    // å˜´å·´å¤–è½®å»“ 44-55
                    [200, 220], [205, 225], [210, 228], [215, 230], [220, 230], [225, 230],
                    [230, 230], [235, 228], [240, 225], [235, 235], [230, 240], [225, 240],
                    
                    // å˜´å·´å†…è½®å»“ 56-61
                    [210, 230], [215, 232], [220, 232], [225, 232], [230, 230], [220, 235],
                    
                    // é¼»å°–ä¸Šæ–¹ 62
                    [220, 180],
                    
                    // å·¦çœ¼ä¸‹æ–¹é¢å¤–ç‚¹ 63-66
                    [185, 175], [195, 180], [205, 175], [200, 180],
                    
                    // å³çœ¼ä¸‹æ–¹é¢å¤–ç‚¹ 67-70
                    [235, 175], [245, 180], [255, 175], [250, 180]
                ];

                // ç›®æ ‡ç‚¹ä½ï¼ˆç˜¦è„¸æ•ˆæœï¼šæ”¶çª„è„¸éƒ¨è½®å»“ï¼‰
                const targetPoints = sourcePoints.map((point, index) => {
                    let [x, y] = point;
                    
                    // å¯¹è„¸éƒ¨è½®å»“è¿›è¡Œç˜¦è„¸å¤„ç†
                    if (index <= 14) { // è„¸éƒ¨è½®å»“ç‚¹ (0-14)
                        const centerX = 220; // è„¸éƒ¨ä¸­å¿ƒXåæ ‡
                        
                        // æ ¹æ®ä¸åŒåŒºåŸŸä½¿ç”¨ä¸åŒçš„æ”¶çª„ç³»æ•°
                        let factor;
                        if (index <= 4 || index >= 12) {
                            // è„¸é¢ŠåŒºåŸŸ - æ›´å¼ºçš„æ”¶çª„
                            factor = 0.6;
                        } else if (index <= 8) {
                            // ä¸‹é¢ŒåŒºåŸŸ - ä¸­ç­‰æ”¶çª„
                            factor = 0.75;
                        } else {
                            // å…¶ä»–åŒºåŸŸ - è½»å¾®æ”¶çª„
                            factor = 0.85;
                        }
                        
                        x = centerX + (x - centerX) * factor;
                    }
                    
                    return [x, y];
                });

                return { sourcePoints, targetPoints };
            }

            // ğŸŒ åˆå§‹åŒ–å…³é”®ç‚¹æ¥æ”¶ WebSocket
            initLandmarkSocket() {
                try {
                    console.log('ğŸŒ è¿æ¥å…³é”®ç‚¹æ¥æ”¶æœåŠ¡å™¨...');
                    this.landmarkSocket = new WebSocket('ws://localhost:3003?type=receiver');
                    
                    this.landmarkSocket.onopen = () => {
                        console.log('âœ… å…³é”®ç‚¹æ¥æ”¶ WebSocket è¿æ¥æˆåŠŸ');
                        this.isLandmarkSocketConnected = true;
                        this.updateDeformStatus('âœ… é¢éƒ¨å½¢å˜ç³»ç»Ÿå°±ç»ª + WebSocketè¿æ¥æˆåŠŸ');
                    };
                    
                    this.landmarkSocket.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);
                            
                            if (message.type === 'landmarks') {
                                if (message.role === 'source') {
                                    // æ¥æ”¶æˆ‘çš„è½®å»“æ•°æ®
                                    this.sourcePtsCache = message.pts71;
                                    this.lastSourceFrame = message.frame || Date.now();
                                    
                                    console.log(`ğŸŒ æ¥æ”¶ source è½®å»“: ${this.sourcePtsCache.length} ä¸ªç‚¹ (frame: ${this.lastSourceFrame})`);
                                } else if (message.role === 'target') {
                                    // æ¥æ”¶æ˜æ˜Ÿè½®å»“æ•°æ®
                                    this.targetPtsCache = message.pts71;
                                    this.lastTargetFrame = message.frame || Date.now();
                                    
                                    console.log(`ğŸŒ æ¥æ”¶ target è½®å»“: ${this.targetPtsCache.length} ä¸ªç‚¹ (frame: ${this.lastTargetFrame})`);
                                }
                                
                                // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                                const status = `source: ${this.sourcePtsCache ? 'âœ…' : 'âŒ'} | target: ${this.targetPtsCache ? 'âœ…' : 'âŒ'}`;
                                this.updateDeformStatus(`ğŸŒ å®æ—¶æ•°æ®: ${status}`);
                            } else if (message.type === 'welcome') {
                                console.log('ğŸŒ æ”¶åˆ°æ¬¢è¿æ¶ˆæ¯:', message.message);
                            }
                            
                        } catch (error) {
                            console.warn('âš ï¸ å…³é”®ç‚¹ WebSocket æ¶ˆæ¯è§£æå¤±è´¥:', error);
                        }
                    };
                    
                    this.landmarkSocket.onclose = () => {
                        console.log('âŒ å…³é”®ç‚¹æ¥æ”¶ WebSocket è¿æ¥æ–­å¼€');
                        this.isLandmarkSocketConnected = false;
                        this.updateDeformStatus('âš ï¸ å½¢å˜ç³»ç»Ÿè¿è¡Œä¸­ï¼ŒWebSocketå·²æ–­å¼€');
                        
                        // 5ç§’åå°è¯•é‡è¿
                        setTimeout(() => {
                            if (!this.isLandmarkSocketConnected) {
                                this.initLandmarkSocket();
                            }
                        }, 5000);
                    };
                    
                    this.landmarkSocket.onerror = (error) => {
                        console.error('âŒ å…³é”®ç‚¹æ¥æ”¶ WebSocket é”™è¯¯:', error);
                        this.isLandmarkSocketConnected = false;
                    };
                    
                } catch (error) {
                    console.error('âŒ å…³é”®ç‚¹æ¥æ”¶ WebSocket åˆå§‹åŒ–å¤±è´¥:', error);
                    this.isLandmarkSocketConnected = false;
                }
            }

            // ğŸ­ æ‰§è¡Œé¢éƒ¨å½¢å˜
            performFaceDeform(sourceImage) {
                if (!this.isDeformReady || !this.isDeformEnabled || !this.faceDeformer) {
                    return sourceImage;
                }

                try {
                    let sourcePoints, targetPoints;
                    
                    // ğŸŒ ä½¿ç”¨å®æ—¶æ•°æ®è¿›è¡Œå½¢å˜ (æ”¯æŒ test å’Œ slim æ¨¡å¼)
                    if (this.sourcePtsCache && (this.deformMode === 'test' || this.deformMode === 'slim')) {
                        // ä½¿ç”¨å®æ—¶æ¥æ”¶çš„æˆ‘çš„è½®å»“ä½œä¸º source
                        sourcePoints = this.sourcePtsCache;
                        
                        // ç”Ÿæˆç˜¦è„¸ç›®æ ‡ç‚¹ (å¯¹è½®å»“è¿›è¡Œæ”¶çª„)
                        targetPoints = sourcePoints.map((point, index) => {
                            let [x, y] = point;
                            
                            // å¯¹è„¸éƒ¨è½®å»“è¿›è¡Œç˜¦è„¸å¤„ç†
                            if (index <= 14) { // è„¸éƒ¨è½®å»“ç‚¹ (0-14)
                                // ä½¿ç”¨é¢éƒ¨ä¸­å¿ƒä½œä¸ºåŸºå‡†ç‚¹
                                const leftCheek = sourcePoints[0] ? sourcePoints[0][0] : x;
                                const rightCheek = sourcePoints[14] ? sourcePoints[14][0] : x;
                                const centerX = (leftCheek + rightCheek) / 2;
                                
                                // æ ¹æ®ä¸åŒåŒºåŸŸä½¿ç”¨ä¸åŒçš„æ”¶çª„ç³»æ•°
                                let factor;
                                if (index <= 4 || index >= 12) {
                                    // è„¸é¢ŠåŒºåŸŸ - æ›´å¼ºçš„æ”¶çª„
                                    factor = 0.6;
                                } else if (index <= 8) {
                                    // ä¸‹é¢ŒåŒºåŸŸ - ä¸­ç­‰æ”¶çª„
                                    factor = 0.75;
                                } else {
                                    // å…¶ä»–åŒºåŸŸ - è½»å¾®æ”¶çª„
                                    factor = 0.85;
                                }
                                
                                x = centerX + (x - centerX) * factor;
                            }
                            
                            return [x, y];
                        });
                        
                        // è®¡ç®—ç˜¦è„¸æ•ˆæœç»Ÿè®¡
                        const faceWidth = Math.abs(sourcePoints[14][0] - sourcePoints[0][0]);
                        const targetWidth = Math.abs(targetPoints[14][0] - targetPoints[0][0]);
                        const slimmingRate = ((faceWidth - targetWidth) / faceWidth * 100).toFixed(1);
                        
                        console.log(`ğŸŒ ä½¿ç”¨å®æ—¶ source æ•°æ®è¿›è¡Œå½¢å˜ - ç˜¦è„¸æ•ˆæœ: ${slimmingRate}%`);
                    } else {
                        // å›é€€åˆ°ç¡¬ç¼–ç æµ‹è¯•æ•°æ®
                        const testData = this.getTestPoints();
                        sourcePoints = testData.sourcePoints;
                        targetPoints = testData.targetPoints;
                        
                        console.log('ğŸ”„ ä½¿ç”¨ç¡¬ç¼–ç æµ‹è¯•æ•°æ®è¿›è¡Œå½¢å˜');
                    }
                    
                    // const vertices = this.getVertices();
                    
                    // åº”ç”¨å½¢å˜å¼ºåº¦
                    let interpolatedPoints = sourcePoints.map((sourcePoint, index) => {
                        const targetPoint = targetPoints[index];
                        return [
                            sourcePoint[0] + (targetPoint[0] - sourcePoint[0]) * this.deformIntensity,
                            sourcePoint[1] + (targetPoint[1] - sourcePoint[1]) * this.deformIntensity
                        ];
                    });

                    // åˆ›å»ºä¸´æ—¶ç”»å¸ƒ
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = sourceImage.width || this.canvas.width;
                    tempCanvas.height = sourceImage.height || this.canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // ç»˜åˆ¶æºå›¾åƒåˆ°ä¸´æ—¶ç”»å¸ƒ
                    if (sourceImage instanceof HTMLImageElement || sourceImage instanceof HTMLCanvasElement) {
                        tempCtx.drawImage(sourceImage, 0, 0, tempCanvas.width, tempCanvas.height);
                    } else {
                        console.warn('âš ï¸ æºå›¾åƒæ ¼å¼ä¸æ”¯æŒï¼Œè·³è¿‡å½¢å˜');
                        return sourceImage;
                    }

                    // === ç”Ÿæˆæ‰©å±•ç‚¹ä¸ä¸‰è§’å½¢ ===
                    // å‚ç…§ clmtrackr facedeform ç¤ºä¾‹ï¼šåœ¨è„¸éƒ¨å‘¨å›´æ·»åŠ  23 ä¸ªæ”¾å¤§ç‚¹ï¼Œç´¢å¼• 71-93
                    const centerIdx = 62; // ä»¥é¼»å°–ä¸Šæ–¹ç‚¹ä¸ºä¸­å¿ƒ
                    if (sourcePoints.length >= 63) {
                        let addPos = [];
                        for (let i = 0; i < 23; i++) {
                            const base = sourcePoints[i];
                            const center = sourcePoints[centerIdx];
                            const newX = (base[0] - center[0]) * 1.3 + center[0];
                            const newY = (base[1] - center[1]) * 1.3 + center[1];
                            addPos.push([newX, newY]);
                        }
                        const newPos = sourcePoints.concat(addPos); // 94 ä¸ªç‚¹

                        // å¤åˆ¶ pModel åŸæœ‰ä¸‰è§’å¹¶æ‹¼æ¥æ‰©å±•ä¸‰è§’
                        const extendVertices = [
                            [0,71,72,0],[0,72,1,0],[1,72,73,1],[1,73,2,1],[2,73,74,2],[2,74,3,2],
                            [3,74,75,3],[3,75,4,3],[4,75,76,4],[4,76,5,4],[5,76,77,5],[5,77,6,5],
                            [6,77,78,6],[6,78,7,6],[7,78,79,7],[7,79,8,7],[8,79,80,8],[8,80,9,8],
                            [9,80,81,9],[9,81,10,9],[10,81,82,10],[10,82,11,10],[11,82,83,11],
                            [11,83,12,11],[12,83,84,12],[12,84,13,12],[13,84,85,13],[13,85,14,13],
                            [14,85,86,14],[14,86,15,14],[15,86,87,15],[15,87,16,15],[16,87,88,16],
                            [16,88,17,16],[17,88,89,17],[17,89,18,17],[18,89,93,18],[18,93,22,18],
                            [22,93,21,22],[93,92,21,93],[21,92,20,21],[92,91,20,92],[20,91,19,20],
                            [91,90,19,91],[19,90,71,19],[19,71,0,19]
                        ];

                        const newVertices = (pModel.path && pModel.path.vertices) ? pModel.path.vertices.concat(extendVertices) : extendVertices;

                        // æ¯3å¸§æ‰é‡æ–°åŠ è½½çº¹ç†ï¼Œå…¶ä»–å¸§ä»… draw
                        if (this.deformFrameCounter % 3 === 0) {
                            this.faceDeformer.load(tempCanvas, newPos, pModel, newVertices);
                        }

                        // è¡¥å…¨ interpolatedPoints ä¸ newPos ä¸€è‡´
                        interpolatedPoints = interpolatedPoints.concat(addPos);
                    } else {
                        // å›é€€ï¼šä½¿ç”¨åŸå§‹ vertices
                        this.faceDeformer.load(tempCanvas, sourcePoints, pModel, this.jawVertices || undefined);
                    }
                    
                    // ğŸ¨ å…ˆç»˜åˆ¶å®Œæ•´èƒŒæ™¯åˆ° deformCanvasï¼Œå†æ‰§è¡Œå½¢å˜
                    const deformCtx = this.deformCanvas.getContext('2d');
                    if (deformCtx) {
                        // æ¸…ç©ºå¹¶ç»˜åˆ¶å®Œæ•´çš„åŸå§‹ç”»é¢ä½œä¸ºèƒŒæ™¯
                        deformCtx.clearRect(0, 0, this.deformCanvas.width, this.deformCanvas.height);
                        deformCtx.drawImage(sourceImage, 0, 0, this.deformCanvas.width, this.deformCanvas.height);
                    }
                    
                    // è®¾ç½® WebGL é€æ˜èƒŒæ™¯ï¼Œè®©å½¢å˜ç»“æœå åŠ åœ¨èƒŒæ™¯ä¸Š
                    if (this.webGLContext) {
                        this.webGLContext.clearColor(0, 0, 0, 0); // é€æ˜èƒŒæ™¯
                        this.webGLContext.clear(this.webGLContext.COLOR_BUFFER_BIT);
                    }

                    // â±ï¸ å¸§ç‡ä¸¢å¸§é€»è¾‘ï¼šé™åˆ¶åˆ° ~20 FPS (>=50ms)
                    const now = performance.now();
                    if (now - this.lastDeformTime >= 50) {
                        this.deformFrameCounter++;
                        this.faceDeformer.draw(interpolatedPoints);
                        this.lastDeformTime = now;
                    }
                    
                    return this.deformCanvas;
                    
                } catch (error) {
                    console.error('âŒ é¢éƒ¨å½¢å˜æ‰§è¡Œå¤±è´¥:', error);
                    this.updateDeformStatus('âŒ å½¢å˜å¤±è´¥: ' + error.message);
                    return sourceImage;
                }
            }

            drawWaitingScreen() {
                this.ctx.fillStyle = '#1a1a1a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.fillStyle = '#FFD700';
                this.ctx.font = '24px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('ğŸ¬ ç­‰å¾…åˆæˆç”»é¢...', this.canvas.width / 2, this.canvas.height / 2 - 20);
                
                this.ctx.fillStyle = '#888';
                this.ctx.font = '14px Arial';
                this.ctx.fillText('ğŸ­ é¢éƒ¨å½¢å˜ç³»ç»Ÿå·²å¯ç”¨', this.canvas.width / 2, this.canvas.height / 2 + 20);
            }

            connectToSource() {
                try {
                    // è¿æ¥åˆ° WebSocket æœåŠ¡å™¨æ¥æ”¶åˆæˆç”»é¢
                    this.websocket = new WebSocket('ws://localhost:3002?type=receiver');
                    
                    this.websocket.onopen = () => {
                        console.log('âœ… WebSocket è¿æ¥æˆåŠŸ');
                        this.isConnected = true;
                        this.updateStatus('å·²è¿æ¥', 'success');
                        document.getElementById('connectionStatus').textContent = 'å·²è¿æ¥';
                        document.getElementById('connectionStatus').className = 'success';
                    };

                    // ğŸ­ ä¸¢å¸§ï¼šå§‹ç»ˆåªä¿ç•™æœ€æ–°ä¸€å¸§
                    this.websocket.onmessage = (event) => {
                        this.latestFrameData = event.data;
                        // å¦‚æœå½“å‰æ²¡æœ‰åœ¨è§£ç ï¼Œåˆ™ç«‹å³å¤„ç†
                        if (!this.isDecodingFrame) {
                            this.decodeAndDrawLatestFrame();
                        }
                    };

                    this.websocket.onclose = () => {
                        console.log('âŒ WebSocket è¿æ¥æ–­å¼€');
                        this.isConnected = false;
                        this.updateStatus('è¿æ¥æ–­å¼€', 'error');
                        document.getElementById('connectionStatus').textContent = 'è¿æ¥æ–­å¼€';
                        document.getElementById('connectionStatus').className = 'error';
                        
                        // 5ç§’åè‡ªåŠ¨é‡è¿
                        setTimeout(() => {
                            if (!this.isConnected) {
                                this.connectToSource();
                            }
                        }, 5000);
                    };

                    this.websocket.onerror = (error) => {
                        console.error('âŒ WebSocket é”™è¯¯:', error);
                        this.updateStatus('è¿æ¥é”™è¯¯', 'error');
                    };

                } catch (error) {
                    console.error('âŒ è¿æ¥å¤±è´¥:', error);
                    this.updateStatus('è¿æ¥å¤±è´¥: ' + error.message, 'error');
                    
                    // å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨ HTTP è½®è¯¢
                    this.startHttpPolling();
                }
            }

            startHttpPolling() {
                console.log('ğŸ”„ å¯åŠ¨ HTTP è½®è¯¢æ¨¡å¼...');
                this.updateStatus('HTTP è½®è¯¢æ¨¡å¼æš‚ä¸å¯ç”¨', 'warning');
                
                // æ³¨æ„ï¼šç”±äºåˆ é™¤äº† face-landmarks-server.cjsï¼ŒHTTP API ä¸å†å¯ç”¨
                // è¯·ç¡®ä¿ WebSocket æœåŠ¡å™¨æ­£åœ¨è¿è¡Œä»¥æ¥æ”¶åˆæˆç”»é¢
                console.warn('âš ï¸ HTTP API ä¸å¯ç”¨ï¼Œè¯·ä½¿ç”¨ WebSocket è¿æ¥');
            }

            // ğŸ­ è§£ç å¹¶ç»˜åˆ¶æœ€æ–°å¸§ï¼ˆä¸¢å¼ƒè¿‡æœŸå¸§ï¼‰
            decodeAndDrawLatestFrame() {
                const data = this.latestFrameData;
                if (!data) return;
                this.isDecodingFrame = true;

                const img = new Image();
                img.onload = () => {
                    this.isDecodingFrame = false;
                    this.handleCompositeFrameDecoded(img);
                    // å¦‚æœåœ¨è§£ç æœŸé—´æ–°å¸§åˆæ¥äº†ï¼Œå†æ¬¡å¤„ç†
                    if (this.latestFrameData !== data) {
                        this.decodeAndDrawLatestFrame();
                    }
                };
                img.onerror = (err) => {
                    console.error('âŒ å›¾ç‰‡è§£ç å¤±è´¥:', err);
                    this.updateStatus('å›¾ç‰‡è§£ç å¤±è´¥', 'error');
                    this.isDecodingFrame = false;
                };

                if (data instanceof Blob) {
                    img.src = URL.createObjectURL(data);
                } else if (typeof data === 'string') {
                    img.src = data;
                }
            }

            // ğŸ­ åŸ handleCompositeFrame é€»è¾‘æ‹†åˆ†ä¸ºç»˜åˆ¶è§£ç å img
            handleCompositeFrameDecoded(img) {
                try {
                    if (!img) return;
                    // æ›´æ–°å°ºå¯¸ç­‰ (ä¸æ—§é€»è¾‘ä¸€è‡´)
                    if (this.canvas.width !== img.width || this.canvas.height !== img.height) {
                        this.canvas.width = img.width;
                        this.canvas.height = img.height;
                        this.deformCanvas.width = img.width;
                        this.deformCanvas.height = img.height;
                        document.getElementById('resolution').textContent = `${img.width}x${img.height}`;
                    }

                    // ğŸ­ å½¢å˜
                    let hasDeform = false;
                    if (this.isDeformEnabled && this.isDeformReady) {
                        this.performFaceDeform(img);
                        hasDeform = true;
                    }

                    // ç»˜åˆ¶
                    let canvasWidth = img.width * this.scale;
                    let canvasHeight = img.height * this.scale;
                    this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                    this.ctx.filter = `brightness(${this.brightness}) contrast(${this.contrast})`;
                    this.ctx.save();
                    this.ctx.scale(-1, 1);
                    this.ctx.translate(-canvasWidth, 0);
                    this.ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                    if (hasDeform) {
                        this.ctx.drawImage(this.deformCanvas, 0, 0, canvasWidth, canvasHeight);
                    }
                    this.ctx.restore();
                    this.ctx.filter = 'none';
                    this.updateFrameRate();
                } catch (error) {
                    console.error('âŒ ç»˜åˆ¶å¸§å¤±è´¥:', error);
                    this.updateStatus('ç»˜åˆ¶å¸§å¤±è´¥: ' + error.message, 'error');
                }
            }

            updateFrameRate() {
                this.frameCount++;
                const currentTime = Date.now();
                const elapsed = (currentTime - this.startTime) / 1000;
                
                if (elapsed >= 1) {
                    const fps = Math.round(this.frameCount / elapsed);
                    document.getElementById('fps').textContent = fps;
                    
                    // é‡ç½®è®¡æ•°å™¨
                    this.frameCount = 0;
                    this.startTime = currentTime;
                }
            }

            // ğŸ­ æ›´æ–°å½¢å˜çŠ¶æ€æ˜¾ç¤º
            updateDeformStatus(status) {
                const statusElement = document.getElementById('deformStatus');
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }

            setupControls() {
                // ç¼©æ”¾æ§åˆ¶
                const scaleSlider = document.getElementById('scaleSlider');
                const scaleValue = document.getElementById('scaleValue');
                
                scaleSlider.addEventListener('input', (e) => {
                    this.scale = e.target.value / 100;
                    scaleValue.textContent = e.target.value + '%';
                });

                // äº®åº¦æ§åˆ¶
                const brightnessSlider = document.getElementById('brightnessSlider');
                const brightnessValue = document.getElementById('brightnessValue');
                
                brightnessSlider.addEventListener('input', (e) => {
                    this.brightness = e.target.value / 100;
                    brightnessValue.textContent = e.target.value + '%';
                });

                // å¯¹æ¯”åº¦æ§åˆ¶
                const contrastSlider = document.getElementById('contrastSlider');
                const contrastValue = document.getElementById('contrastValue');
                
                contrastSlider.addEventListener('input', (e) => {
                    this.contrast = e.target.value / 100;
                    contrastValue.textContent = e.target.value + '%';
                });

                // ğŸ­ é¢éƒ¨å½¢å˜æ§åˆ¶
                const enableDeform = document.getElementById('enableDeform');
                const deformIntensitySlider = document.getElementById('deformIntensitySlider');
                const deformIntensityValue = document.getElementById('deformIntensityValue');
                const deformMode = document.getElementById('deformMode');
                const testDeformBtn = document.getElementById('testDeformBtn');
                const resetDeformBtn = document.getElementById('resetDeformBtn');

                enableDeform.addEventListener('change', (e) => {
                    this.isDeformEnabled = e.target.checked;
                    this.updateDeformStatus(this.isDeformEnabled ? 'âœ… å½¢å˜å·²å¯ç”¨' : 'â¸ï¸ å½¢å˜å·²æš‚åœ');
                });

                deformIntensitySlider.addEventListener('input', (e) => {
                    this.deformIntensity = e.target.value / 100;
                    deformIntensityValue.textContent = e.target.value + '%';
                });

                deformMode.addEventListener('change', (e) => {
                    this.deformMode = e.target.value;
                    this.updateDeformStatus(`æ¨¡å¼å·²åˆ‡æ¢: ${e.target.value}`);
                });

                testDeformBtn.addEventListener('click', () => {
                    this.testDeformation();
                });

                resetDeformBtn.addEventListener('click', () => {
                    this.resetDeformation();
                });

                // å…¨å±æŒ‰é’®
                document.getElementById('fullscreenBtn').addEventListener('click', () => {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.documentElement.requestFullscreen();
                    }
                });

                // ä¿å­˜å½“å‰å¸§
                document.getElementById('saveFrameBtn').addEventListener('click', () => {
                    this.saveCurrentFrame();
                });

                // é‡ç½®è®¾ç½®
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.resetSettings();
                });

                // é‡æ–°è¿æ¥
                document.getElementById('reconnectBtn').addEventListener('click', () => {
                    this.reconnect();
                });
            }

            // ğŸ­ æµ‹è¯•å½¢å˜åŠŸèƒ½
            testDeformation() {
                if (!this.isDeformReady) {
                    this.updateDeformStatus('âŒ å½¢å˜ç³»ç»Ÿæœªå°±ç»ª');
                    return;
                }

                try {
                    // åˆ›å»ºæµ‹è¯•å›¾åƒ
                    const testCanvas = document.createElement('canvas');
                    testCanvas.width = 640;
                    testCanvas.height = 480;
                    const testCtx = testCanvas.getContext('2d');
                    
                    // ç»˜åˆ¶æµ‹è¯•å›¾åƒ
                    testCtx.fillStyle = '#f0f0f0';
                    testCtx.fillRect(0, 0, 640, 480);
                    testCtx.fillStyle = '#333';
                    testCtx.font = '30px Arial';
                    testCtx.textAlign = 'center';
                    testCtx.fillText('ğŸ­ å½¢å˜æµ‹è¯•', 320, 240);
                    
                    // æ‰§è¡Œå½¢å˜
                    const result = this.performFaceDeform(testCanvas);
                    this.updateDeformStatus('âœ… å½¢å˜æµ‹è¯•å®Œæˆ');
                    
                } catch (error) {
                    console.error('âŒ å½¢å˜æµ‹è¯•å¤±è´¥:', error);
                    this.updateDeformStatus('âŒ å½¢å˜æµ‹è¯•å¤±è´¥: ' + error.message);
                }
            }

            // ğŸ­ é‡ç½®å½¢å˜
            resetDeformation() {
                this.deformIntensity = 1.0;
                document.getElementById('deformIntensitySlider').value = 100;
                document.getElementById('deformIntensityValue').textContent = '100%';
                this.updateDeformStatus('ğŸ”„ å½¢å˜å‚æ•°å·²é‡ç½®');
            }

            saveCurrentFrame() {
                try {
                    const activeCanvas = this.isDeformEnabled && this.isDeformReady ? this.deformCanvas : this.canvas;
                    const link = document.createElement('a');
                    link.download = `composite-frame-${Date.now()}.png`;
                    link.href = activeCanvas.toDataURL();
                    link.click();
                    
                    this.updateStatus('å½“å‰å¸§å·²ä¿å­˜', 'success');
                } catch (error) {
                    console.error('âŒ ä¿å­˜å¤±è´¥:', error);
                    this.updateStatus('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
                }
            }

            resetSettings() {
                this.scale = 1.0;
                this.brightness = 1.0;
                this.contrast = 1.0;
                
                document.getElementById('scaleSlider').value = 100;
                document.getElementById('scaleValue').textContent = '100%';
                document.getElementById('brightnessSlider').value = 100;
                document.getElementById('brightnessValue').textContent = '100%';
                document.getElementById('contrastSlider').value = 100;
                document.getElementById('contrastValue').textContent = '100%';
                
                this.updateStatus('è®¾ç½®å·²é‡ç½®', 'success');
            }

            reconnect() {
                if (this.websocket) {
                    this.websocket.close();
                }
                this.updateStatus('æ­£åœ¨é‡æ–°è¿æ¥...', 'warning');
                setTimeout(() => {
                    this.connectToSource();
                }, 1000);
            }

            updateStatus(message, type = 'info') {
                const statusText = document.getElementById('statusText');
                statusText.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                statusText.className = type;
                
                console.log(`ğŸ“Š [${type.toUpperCase()}] ${message}`);
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸ¬ åˆæˆç”»é¢æ˜¾ç¤ºå™¨ + ğŸ­ é¢éƒ¨å½¢å˜ç³»ç»Ÿå·²å¯åŠ¨');
            const receiver = new CompositeVideoReceiver();
            
            // å…¨å±€é”™è¯¯å¤„ç†
            window.addEventListener('error', (error) => {
                console.error('âŒ å…¨å±€é”™è¯¯:', error);
                receiver.updateStatus('ç³»ç»Ÿé”™è¯¯: ' + error.message, 'error');
            });

            // é¡µé¢å¯è§æ€§å˜åŒ–å¤„ç†
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    console.log('ğŸ“´ é¡µé¢éšè—ï¼Œæš‚åœæ¥æ”¶');
                } else {
                    console.log('ğŸ“º é¡µé¢æ˜¾ç¤ºï¼Œæ¢å¤æ¥æ”¶');
                    receiver.reconnect();
                }
            });

            // çª—å£å¤§å°å˜åŒ–å¤„ç†
            window.addEventListener('resize', () => {
                // è§¦å‘ç”»é¢é‡æ–°è°ƒæ•´ï¼ˆå¦‚æœæœ‰å½“å‰ç”»é¢çš„è¯ï¼‰
                console.log('ğŸ“ çª—å£å¤§å°å·²æ”¹å˜ï¼Œé‡æ–°è°ƒæ•´ç”»é¢å°ºå¯¸');
            });
        });
    </script>
</body>
</html> 