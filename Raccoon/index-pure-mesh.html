<html>

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- ğŸ¯ face-api.js ç”¨äº 3D æ¨¡å‹é¢éƒ¨è¯†åˆ« -->
  
  <script type="module">
    import * as THREE from 'three';
    import { MindARThree } from "../src/face-target/three.js";
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as faceapi from 'face-api.js';
    import { OneEuroFilter } from '1eurofilter';
    
    // ğŸ¯ é¢éƒ¨è¯†åˆ«ç›¸å…³å˜é‡ - ç”¨äºè¯†åˆ«3Dæ¨¡å‹
    let trackingStarted = false;
    let faceDetectorOptions = null; // TinyFaceDetector é…ç½®
    let currentLandmarks = null;    // å¹³æ»‘åçš„å…³é”®ç‚¹
    let landmarkFilters = null;    // 1â‚¬ æ»¤æ³¢å™¨æ•°ç»„
    let facePointsCanvas = null;
    let facePointsCtx = null;
    let modelRenderCanvas = null; // ç”¨äºæ•è·3Dæ¨¡å‹æ¸²æŸ“ç»“æœçš„ç”»å¸ƒ
    let modelRenderCtx = null;
    
    // ğŸ¯ è¯†åˆ«æ€§èƒ½ç»Ÿè®¡
    let detectionStats = {
      totalAttempts: 0,
      successfulDetections: 0,
      lastDetectionTime: 0,
      avgConfidence: 0,
      confidenceSum: 0
    };

    // GPUä¿¡æ¯æ£€æµ‹å’Œæ˜¾ç¤ºï¼ˆå’Œthree-facemesh.htmlä¸€æ ·ï¼‰
    const checkGPUInfo = async () => {
      const canvas = document.createElement('canvas');
      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      
      if (gl) {
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        if (debugInfo) {
          const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
          const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
          
          console.log('ğŸ® å½“å‰ä½¿ç”¨çš„GPUä¿¡æ¯:');
          console.log('ä¾›åº”å•†:', vendor);
          console.log('æ¸²æŸ“å™¨:', renderer);
          
          // åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºGPUä¿¡æ¯
          const infoDiv = document.createElement('div');
          infoDiv.id = 'gpu-info';
          infoDiv.innerHTML = `
            <div style="position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: white; padding: 10px; border-radius: 5px; font-family: monospace; font-size: 12px; z-index: 1000;">
              <strong>ğŸ¦ è„¸éƒ¨æ¨¡å‹AR - çº¯æœ¬åœ°æºç </strong><br/>
              ä¾›åº”å•†: ${vendor}<br/>
              æ¸²æŸ“å™¨: ${renderer}<br/>
              <span id="performance-info"></span><br/>
              <span id="color-info">ğŸ¨ è‚¤è‰²é‡‡æ ·: å‡†å¤‡ä¸­...</span><br/>
              <span id="texture-info">ğŸ–¼ï¸ è‡ªå®šä¹‰è´´å›¾: åˆå§‹åŒ–ä¸­...</span>
            </div>
          `;
          document.body.appendChild(infoDiv);
          
          // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†NVIDIA GPU
          if (renderer.includes('NVIDIA') || renderer.includes('GeForce')) {
            console.log('âœ… æ­£åœ¨ä½¿ç”¨ NVIDIA ç‹¬æ˜¾');
            infoDiv.style.borderLeft = '4px solid green';
          } else if (renderer.includes('Intel')) {
            console.log('âš ï¸ æ­£åœ¨ä½¿ç”¨ Intel æ ¸æ˜¾ï¼Œå»ºè®®åˆ‡æ¢åˆ°ç‹¬æ˜¾');
            infoDiv.style.borderLeft = '4px solid orange';
          }
        }
      }
    };

    // æ€§èƒ½ç›‘æ§
    const addPerformanceMonitor = () => {
      let frameCount = 0;
      let lastTime = performance.now();
      
      const updateFPS = () => {
        frameCount++;
        const currentTime = performance.now();
        if (currentTime - lastTime >= 1000) {
          const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
          const perfInfo = document.getElementById('performance-info');
          if (perfInfo) {
            perfInfo.innerHTML = `<br/>FPS: ${fps}`;
          }
          frameCount = 0;
          lastTime = currentTime;
        }
        requestAnimationFrame(updateFPS);
      };
      updateFPS();
    };

    // ğŸ¯ åˆå§‹åŒ–é¢éƒ¨è¯†åˆ«ç³»ç»Ÿ - ç”¨äºè¯†åˆ«3Dæ¨¡å‹ (face-api.js)
    const initFaceTracking = async () => {
      console.log('ğŸ¯ åˆå§‹åŒ–3Dæ¨¡å‹é¢éƒ¨è¯†åˆ«ç³»ç»Ÿ (face-api.js)...');

      try {
        // ğŸ¯ ä¼˜å…ˆå°è¯•æœ¬åœ°æ¨¡å‹ï¼Œå¤±è´¥æ—¶ä½¿ç”¨ CDN
        let modelLoaded = false;
        
        try {
          console.log('ğŸ“¦ å°è¯•åŠ è½½æœ¬åœ°æ¨¡å‹...');
          await Promise.all([
            faceapi.nets.tinyFaceDetector.loadFromUri('./models'),
            faceapi.nets.faceLandmark68TinyNet.loadFromUri('./models')
          ]);
          modelLoaded = true;
          console.log('âœ… æœ¬åœ°æ¨¡å‹åŠ è½½æˆåŠŸ');
        } catch (localError) {
          console.warn('âš ï¸ æœ¬åœ°æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œå°è¯•CDNæ¨¡å‹:', localError.message);
          
          const MODEL_URL = 'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights';
          await Promise.all([
            faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
            faceapi.nets.faceLandmark68TinyNet.loadFromUri(MODEL_URL)
          ]);
          modelLoaded = true;
          console.log('âœ… CDNæ¨¡å‹åŠ è½½æˆåŠŸ');
        }
        
        // ğŸ¯ ä¼˜åŒ– face-api.js å‚æ•°ï¼Œä¸“é—¨ç”¨äºè¯†åˆ« 3D æ¨¡å‹
        faceDetectorOptions = new faceapi.TinyFaceDetectorOptions({ 
          inputSize: 256,        // æé«˜è¾“å…¥å°ºå¯¸ï¼Œå¢åŠ è¯†åˆ«ç²¾åº¦
          scoreThreshold: 0.3    // é™ä½é˜ˆå€¼ï¼Œæé«˜æ£€æµ‹æ•æ„Ÿåº¦
        });
        console.log('âœ… face-api.js æ¨¡å‹åŠ è½½å®Œæˆ (ä¸“é—¨è¯†åˆ«3Dæ¨¡å‹ï¼Œ<inputSize:256>, <scoreThreshold:0.3>)');
      } catch (error) {
        console.error('âŒ face-api.js æ¨¡å‹åŠ è½½å¤±è´¥:', error);
        return false;
      }
      
      // åˆ›å»ºç”¨äºæ•è·3Dæ¨¡å‹æ¸²æŸ“ç»“æœçš„ç”»å¸ƒ - 16:9æ¯”ä¾‹åŒ¹é…æ‘„åƒæœº
      modelRenderCanvas = document.createElement('canvas');
      modelRenderCanvas.width = 640;  // 16:9æ¯”ä¾‹ï¼Œä¸æ‘„åƒæœºè¾“å…¥åŒ¹é…
      modelRenderCanvas.height = 360; // 640/360 = 16:9
      modelRenderCtx = modelRenderCanvas.getContext('2d');
      
      // ğŸ¯ æé«˜ç”»å¸ƒæ¸²æŸ“è´¨é‡
      modelRenderCtx.imageSmoothingEnabled = true;
      modelRenderCtx.imageSmoothingQuality = 'high';
      
      // åˆ›å»ºé¢éƒ¨ç‚¹ä½ç»˜åˆ¶ç”»å¸ƒè¦†ç›–å±‚
      facePointsCanvas = document.createElement('canvas');
      facePointsCanvas.id = 'face-points-overlay';
      facePointsCanvas.style.position = 'absolute';
      facePointsCanvas.style.top = '0px';
      facePointsCanvas.style.left = '0px';
      facePointsCanvas.style.pointerEvents = 'none';
      facePointsCanvas.style.zIndex = '1000';
      facePointsCtx = facePointsCanvas.getContext('2d');
      
      // æ·»åŠ åˆ°å®¹å™¨
      const container = document.querySelector('#container');
      if (container) {
        container.appendChild(facePointsCanvas);
        
        // ğŸ” è°ƒè¯•ç”¨çš„æ¸²æŸ“ç”»å¸ƒæ˜¾ç¤ºï¼ˆç”¨äºæŸ¥çœ‹face-api.jsçš„è¾“å…¥ï¼‰- 16:9æ¯”ä¾‹
        modelRenderCanvas.style.position = 'absolute';
        modelRenderCanvas.style.top = '10px';
        modelRenderCanvas.style.left = '10px';
        modelRenderCanvas.style.width = '240px';  // 16:9æ¯”ä¾‹æ˜¾ç¤º
        modelRenderCanvas.style.height = '135px'; // 240/135 = 16:9
        modelRenderCanvas.style.border = '3px solid #00FF00';
        modelRenderCanvas.style.borderRadius = '8px';
        modelRenderCanvas.style.zIndex = '999';
        modelRenderCanvas.style.opacity = '0.9';
        modelRenderCanvas.style.boxShadow = '0 0 10px rgba(0,255,0,0.5)';
        modelRenderCanvas.title = '3Dæ¨¡å‹è¯†åˆ«è¾“å…¥ç”»é¢ (face-api.js) - 16:9æ¯”ä¾‹';
        container.appendChild(modelRenderCanvas);
      }
      
      // ğŸ¯ æ€§èƒ½ç›‘æ§å·²ç§»é™¤ï¼ˆä½¿ç”¨æµè§ˆå™¨å¼€å‘è€…å·¥å…·ä»£æ›¿ï¼‰
      console.log('ğŸ“Š æ€§èƒ½ç›‘æ§ï¼šè¯·ä½¿ç”¨æµè§ˆå™¨å¼€å‘è€…å·¥å…· > Performance æ ‡ç­¾');
      
      return true;
    };
    
    // ğŸ¯ åˆå§‹åŒ– 1â‚¬ æ»¤æ³¢å™¨ï¼ˆ68ä¸ªå…³é”®ç‚¹ Ã— 2åæ ‡ = 136ä¸ªæ»¤æ³¢å™¨ï¼‰
    const initLandmarkFilters = () => {
      console.log('ğŸ”§ åˆå§‹åŒ– 1â‚¬ æ»¤æ³¢å™¨ (3Dæ¨¡å‹è¯†åˆ«)...');
      
      // 1â‚¬ æ»¤æ³¢å™¨å‚æ•°ï¼šå¹³è¡¡å¹³æ»‘æ€§å’Œå»¶è¿Ÿ
      const filterParams = {
        freq: 30,        // ä¼°è®¡å¸§ç‡ 30fps
        mincutoff: 1.0,  // æœ€å°æˆªæ­¢é¢‘ç‡ï¼š1.0Hz = å¼ºå¹³æ»‘
        beta: 0.04,      // é€Ÿåº¦å“åº”ç³»æ•°ï¼š0.04 = ä½å»¶è¿Ÿ
        dcutoff: 1.0     // å¯¼æ•°æ»¤æ³¢æˆªæ­¢é¢‘ç‡
      };
      
      landmarkFilters = [];
      // ä¸º68ä¸ªå…³é”®ç‚¹çš„xã€yåæ ‡å„åˆ›å»ºæ»¤æ³¢å™¨
      for (let i = 0; i < 68; i++) {
        landmarkFilters.push({
          x: new OneEuroFilter(filterParams.freq, filterParams.mincutoff, filterParams.beta, filterParams.dcutoff),
          y: new OneEuroFilter(filterParams.freq, filterParams.mincutoff, filterParams.beta, filterParams.dcutoff)
        });
      }
      
      console.log('âœ… 1â‚¬ æ»¤æ³¢å™¨åˆå§‹åŒ–å®Œæˆï¼š68ä¸ªå…³é”®ç‚¹ Ã— 2åæ ‡ = 136ä¸ªæ»¤æ³¢å™¨ (3Dæ¨¡å‹è¯†åˆ«)');
    };
    
    // ğŸ¯ å¼€å§‹3Dæ¨¡å‹é¢éƒ¨è·Ÿè¸ª
    const startFaceTracking = () => {
      if (!modelRenderCanvas || !faceDetectorOptions) {
        console.warn('âš ï¸ face-api.js æœªå°±ç»ª');
        return false;
      }
      trackingStarted = true;
      console.log('âœ… 3Dæ¨¡å‹é¢éƒ¨æ£€æµ‹å·²å¯åŠ¨ (face-api.js)');
      return true;
    };
    
    // ğŸ¯ è°ƒæ•´é¢éƒ¨ç‚¹ä½ç”»å¸ƒå°ºå¯¸å’Œç¼©æ”¾æ¯”ä¾‹ - ç”¨äº3Dæ¨¡å‹è¯†åˆ«
    let modelScaleX = 1;
    let modelScaleY = 1;
    let modelOffsetX = 0;
    let modelOffsetY = 0;
    
    const adjustFacePointsCanvas = () => {
      if (!facePointsCanvas || !modelRenderCanvas) return;
      
      const container = document.querySelector('#container');
      
      if (container) {
        // è®¾ç½®è¦†ç›–å±‚ç”»å¸ƒå°ºå¯¸ä¸å®¹å™¨ä¸€è‡´
        facePointsCanvas.width = container.clientWidth;
        facePointsCanvas.height = container.clientHeight;
        facePointsCanvas.style.width = container.clientWidth + 'px';
        facePointsCanvas.style.height = container.clientHeight + 'px';
        
        // ğŸ¯ è®¡ç®—ä»3Dæ¨¡å‹è¯†åˆ«ç”»å¸ƒåˆ°æ˜¾ç¤ºç”»å¸ƒçš„ç¼©æ”¾æ¯”ä¾‹
        const modelRatio = modelRenderCanvas.width / modelRenderCanvas.height;
        const containerRatio = container.clientWidth / container.clientHeight;
        
        let displayWidth, displayHeight;
        if (modelRatio > containerRatio) {
          displayHeight = container.clientHeight;
          displayWidth = displayHeight * modelRatio;
        } else {
          displayWidth = container.clientWidth;
          displayHeight = displayWidth / modelRatio;
        }
        
        // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹å’Œåç§»é‡
        modelScaleX = displayWidth / modelRenderCanvas.width;
        modelScaleY = displayHeight / modelRenderCanvas.height;
        modelOffsetX = (container.clientWidth - displayWidth) / 2;
        modelOffsetY = (container.clientHeight - displayHeight) / 2;
        
        console.log('ğŸ¯ 3Dæ¨¡å‹è¯†åˆ«ç”»å¸ƒå°ºå¯¸å’Œç¼©æ”¾æ¯”ä¾‹è°ƒæ•´:', {
          overlayCanvasSize: `${facePointsCanvas.width}x${facePointsCanvas.height}`,
          modelCanvasSize: `${modelRenderCanvas.width}x${modelRenderCanvas.height}`,
          displaySize: `${displayWidth}x${displayHeight}`,
          scaleX: modelScaleX,
          scaleY: modelScaleY,
          offsetX: modelOffsetX,
          offsetY: modelOffsetY
        });
      }
    };
    
    // ğŸ¯ æ•è·3Dæ¨¡å‹æ¸²æŸ“ç»“æœå¹¶è¿›è¡Œé¢éƒ¨è¯†åˆ« - ä¼˜åŒ–ç‰ˆæœ¬
    const captureAndAnalyze3DModel = (renderer) => {
      if (!modelRenderCtx || !renderer) return;
      
      try {
        // ä»Three.jsæ¸²æŸ“å™¨è·å–ç”»é¢å¹¶ç»˜åˆ¶åˆ°è¯†åˆ«ç”»å¸ƒ
        const threeCanvas = renderer.domElement;
        
        // ğŸ¯ æ¸…é™¤ç”»å¸ƒå¹¶è®¾ç½®èƒŒæ™¯è‰²ï¼Œæé«˜å¯¹æ¯”åº¦
        modelRenderCtx.fillStyle = '#000000'; // é»‘è‰²èƒŒæ™¯  
        modelRenderCtx.fillRect(0, 0, modelRenderCanvas.width, modelRenderCanvas.height);
        
        // ğŸ¯ è®¡ç®—æ­£ç¡®çš„æ¯”ä¾‹æ˜ å°„ï¼Œé¿å…å‹ç¼©å˜å½¢
        const targetRatio = modelRenderCanvas.width / modelRenderCanvas.height; // 16:9 = 1.778
        const sourceRatio = threeCanvas.width / threeCanvas.height;
        
        let drawWidth, drawHeight, drawX, drawY;
        
        if (sourceRatio > targetRatio) {
          // æºç”»å¸ƒæ›´å®½ï¼ŒæŒ‰é«˜åº¦ç¼©æ”¾ï¼Œæ°´å¹³å±…ä¸­
          drawHeight = modelRenderCanvas.height;
          drawWidth = drawHeight * sourceRatio;
          drawX = (modelRenderCanvas.width - drawWidth) / 2;
          drawY = 0;
        } else {
          // æºç”»å¸ƒæ›´é«˜ï¼ŒæŒ‰å®½åº¦ç¼©æ”¾ï¼Œå‚ç›´å±…ä¸­
          drawWidth = modelRenderCanvas.width;
          drawHeight = drawWidth / sourceRatio;
          drawX = 0;
          drawY = (modelRenderCanvas.height - drawHeight) / 2;
        }
        
        // æŒ‰æ­£ç¡®æ¯”ä¾‹ç»˜åˆ¶åˆ°è¯†åˆ«ç”»å¸ƒ
        modelRenderCtx.drawImage(threeCanvas, drawX, drawY, drawWidth, drawHeight);
        
        // ğŸ¯ å¢å¼ºå¯¹æ¯”åº¦å’Œæ¸…æ™°åº¦
        const imageData = modelRenderCtx.getImageData(0, 0, modelRenderCanvas.width, modelRenderCanvas.height);
        const data = imageData.data;
        
        // ç®€å•çš„å¯¹æ¯”åº¦å¢å¼º
        const contrast = 1.2; // å¯¹æ¯”åº¦å¢å¼ºç³»æ•°
        const brightness = 10; // äº®åº¦å¢å¼º
        
        for (let i = 0; i < data.length; i += 4) {
          // å¢å¼ºå¯¹æ¯”åº¦å’Œäº®åº¦
          data[i] = Math.min(255, Math.max(0, (data[i] - 128) * contrast + 128 + brightness));     // R
          data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * contrast + 128 + brightness)); // G
          data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * contrast + 128 + brightness)); // B
        }
        
        modelRenderCtx.putImageData(imageData, 0, 0);
        
      } catch (error) {
        console.warn('æ•è·3Dæ¨¡å‹æ¸²æŸ“å¤±è´¥:', error);
      }
    };
    
    // ğŸ¯ ç»˜åˆ¶3Dæ¨¡å‹é¢éƒ¨ç‚¹ä½ï¼ˆå¸¦ç¼©æ”¾å’Œåç§»ï¼‰
    const drawFacePoints = () => {
      if (!facePointsCtx || !currentLandmarks) return;

      // æ¸…ç©ºè¦†ç›–å±‚ç”»å¸ƒ
      facePointsCtx.clearRect(0, 0, facePointsCanvas.width, facePointsCanvas.height);

      facePointsCtx.save();
      // ğŸ¯ åº”ç”¨å˜æ¢ï¼šåç§» + ç¼©æ”¾ï¼ˆè¯†åˆ«3Dæ¨¡å‹ï¼Œä¸éœ€è¦ç¿»è½¬ï¼‰
      facePointsCtx.translate(modelOffsetX, modelOffsetY);
      facePointsCtx.scale(modelScaleX, modelScaleY);

      // ç»˜åˆ¶å…³é”®ç‚¹
      facePointsCtx.fillStyle = 'rgba(0,255,0,0.8)';
      currentLandmarks.forEach(pt => {
        facePointsCtx.beginPath();
        facePointsCtx.arc(pt.x, pt.y, 2, 0, Math.PI * 2);
        facePointsCtx.fill();
      });

      facePointsCtx.restore();
    };
    
    // ğŸ¯ æ›´æ–°é¢éƒ¨è¯†åˆ«çŠ¶æ€æ˜¾ç¤º
    const updateFaceTrackingStatus = (status) => {
      const statusElement = document.getElementById('faceTrackingStatus');
      if (statusElement) {
        statusElement.textContent = status;
      }
    };

    // ğŸ¨ è‡ªå®šä¹‰è´´å›¾å¼€å…³ - è®¾ç½®ä¸º true å¯ç”¨è‡ªå®šä¹‰è´´å›¾
    const USE_CUSTOM_TEXTURE = true; // æ”¹ä¸º false å¯å…³é—­è‡ªå®šä¹‰è´´å›¾
    const CUSTOM_TEXTURE_PATH = "../ChatGPT_Image.png";  //_blackWhite  enhanced_texture.png
    
    // ğŸ¨ å…±äº«è°ƒè‰²æ¿é…ç½®ç®¡ç†
    const ColorPaletteManager = {
      // é»˜è®¤é…ç½®
      defaultConfig: {
        customColor: { r: 0.9, g: 0.7, b: 0.6 },
        colorIntensity: 0.8,
        colorMode: 'multiply',
        useAutoColor: true,
        redValue: 230,
        greenValue: 179,
        blueValue: 153
      },
      
      // ä»localStorageåŠ è½½é…ç½®
      loadConfig() {
        try {
          const savedConfig = localStorage.getItem('raccoon-color-palette');
          if (savedConfig) {
            const config = JSON.parse(savedConfig);
            console.log('âœ… å·²åŠ è½½ä¿å­˜çš„è°ƒè‰²æ¿é…ç½®');
            return { ...this.defaultConfig, ...config };
          }
        } catch (error) {
          console.warn('âš ï¸ åŠ è½½è°ƒè‰²æ¿é…ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®:', error);
        }
        return this.defaultConfig;
      },
      
      // ä¿å­˜é…ç½®åˆ°localStorage
      saveConfig(config) {
        try {
          localStorage.setItem('raccoon-color-palette', JSON.stringify(config));
          console.log('ğŸ’¾ è°ƒè‰²æ¿é…ç½®å·²ä¿å­˜');
        } catch (error) {
          console.warn('âš ï¸ ä¿å­˜è°ƒè‰²æ¿é…ç½®å¤±è´¥:', error);
        }
      },
      
      // è·å–å½“å‰é…ç½®
      getCurrentConfig() {
        return {
          customColor: {
            r: customColor.r,
            g: customColor.g,
            b: customColor.b
          },
          colorIntensity,
          colorMode,
          useAutoColor,
          redValue: Math.round(customColor.r * 255),
          greenValue: Math.round(customColor.g * 255),
          blueValue: Math.round(customColor.b * 255)
        };
      }
    };
    
    // åŠ è½½ä¿å­˜çš„é…ç½®
    const savedConfig = ColorPaletteManager.loadConfig();
    
    // ğŸ¨ é¢œè‰²æ§åˆ¶è®¾ç½® - ä½¿ç”¨ä¿å­˜çš„é…ç½®åˆå§‹åŒ–
    let customColor = new THREE.Color(savedConfig.customColor.r, savedConfig.customColor.g, savedConfig.customColor.b);
    let colorIntensity = savedConfig.colorIntensity;
    let colorMode = savedConfig.colorMode;
    let useAutoColor = savedConfig.useAutoColor;
    
    // åˆå§‹åŒ–GPUæ£€æµ‹
    await checkGPUInfo();
    addPerformanceMonitor();
    
    // æ›´æ–°è´´å›¾çŠ¶æ€æ˜¾ç¤º
    const textureInfo = document.getElementById('texture-info');
    if (textureInfo) {
      textureInfo.innerHTML = `ğŸ–¼ï¸ è‡ªå®šä¹‰è´´å›¾: ${USE_CUSTOM_TEXTURE ? 'å¯ç”¨' : 'å…³é—­'}`;
    }
    
    // åˆ›å»ºé¢œè‰²æ§åˆ¶é¢æ¿
    const createColorControlPanel = () => {
      const controlPanel = document.createElement('div');
      controlPanel.id = 'color-control-panel';
      controlPanel.innerHTML = `
        <div style="position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.85); color: white; padding: 15px; border-radius: 8px; font-family: Arial, sans-serif; font-size: 12px; z-index: 1001; width: 250px;">
          <h3 style="margin: 0 0 10px 0; color: #FFD700;">ğŸ¨ å…±äº«è°ƒè‰²æ¿ + ğŸ¯ é¢éƒ¨è¯†åˆ«</h3>
          
          <div style="margin-bottom: 10px; padding: 8px; background: #333; border-radius: 4px;">
            <div style="color: #00FF00; font-weight: bold; margin-bottom: 5px;">ğŸ¯ 3Dæ¨¡å‹é¢éƒ¨è¯†åˆ«</div>
            <div id="faceTrackingStatus" style="color: #888;">åˆå§‹åŒ–ä¸­...</div>
            <div style="font-size: 10px; color: #666; margin-top: 3px;">face-api.js + 1â‚¬æ»¤æ³¢å™¨ (ä½å»¶è¿ŸæŠ—æŠ–åŠ¨)</div>
            
            <details style="margin-top: 8px;">
              <summary style="cursor: pointer; color: #FFD700; font-size: 11px;">ğŸ”§ 1â‚¬æ»¤æ³¢å™¨å‚æ•°è°ƒèŠ‚</summary>
              <div style="margin-top: 5px; font-size: 10px;">
                <div style="margin-bottom: 5px;">
                  <label>MinCutoff (å¹³æ»‘åº¦): <span id="minCutoffValue">1.0</span></label>
                  <input type="range" id="minCutoffSlider" min="0.1" max="2.0" step="0.1" value="1.0" style="width: 100%;">
                </div>
                <div style="margin-bottom: 5px;">
                  <label>Beta (å“åº”é€Ÿåº¦): <span id="betaValue">0.04</span></label>
                  <input type="range" id="betaSlider" min="0.01" max="0.2" step="0.01" value="0.04" style="width: 100%;">
                </div>
                <div style="color: #666; font-size: 9px;">
                  MinCutoffâ†“=æ›´å¹³æ»‘ä½†å»¶è¿Ÿâ†‘<br/>
                  Betaâ†‘=è·Ÿéšæ›´å¿«ä½†å¯èƒ½æŠ–åŠ¨â†‘
                </div>
                <div style="margin-top: 8px; text-align: center;">
                  <button id="smoothPreset" style="background: #555; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; margin-right: 3px; font-size: 9px;">å¹³æ»‘ä¼˜å…ˆ</button>
                  <button id="balancedPreset" style="background: #555; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; margin-right: 3px; font-size: 9px;">å¹³è¡¡æ¨¡å¼</button>
                  <button id="responsivePreset" style="background: #555; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 9px;">å“åº”ä¼˜å…ˆ</button>
                </div>
              </div>
            </details>
          </div>
          

          
          <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">é¢œè‰²æ¨¡å¼:</label>
            <select id="colorModeSelect" style="width: 100%; padding: 3px; background: #333; color: white; border: 1px solid #555;">
              <option value="multiply">ä¹˜æ³•æ··åˆ (æ¨èé»‘ç™½è´´å›¾)</option>
              <option value="overlay">å åŠ æ··åˆ</option>
              <option value="lerp">çº¿æ€§æ’å€¼</option>
            </select>
          </div>
          
          <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 5px;">
              <input type="checkbox" id="useAutoColorCheck" ${useAutoColor ? 'checked' : ''}> è‡ªåŠ¨è‚¤è‰²é‡‡æ ·
            </label>
          </div>
          
          <div id="manualColorControls" style="display: ${useAutoColor ? 'none' : 'block'};">
            <div style="margin-bottom: 8px;">
              <label style="display: block; margin-bottom: 3px;">è‡ªå®šä¹‰é¢œè‰²:</label>
              <input type="color" id="customColorPicker" style="width: 100%; height: 30px; border: none; border-radius: 4px;">
            </div>
          </div>
          
          <div style="margin-bottom: 8px;">
            <label style="display: block; margin-bottom: 3px;">å¼ºåº¦: <span id="intensityValue">${Math.round(colorIntensity * 100)}%</span></label>
            <input type="range" id="intensitySlider" min="0" max="100" value="${Math.round(colorIntensity * 100)}" style="width: 100%;">
          </div>
          
          <div style="margin-bottom: 8px;">
            <label style="display: block; margin-bottom: 3px;">çº¢è‰²: <span id="redValue">${savedConfig.redValue}</span></label>
            <input type="range" id="redSlider" min="0" max="255" value="${savedConfig.redValue}" style="width: 100%;">
          </div>
          
          <div style="margin-bottom: 8px;">
            <label style="display: block; margin-bottom: 3px;">ç»¿è‰²: <span id="greenValue">${savedConfig.greenValue}</span></label>
            <input type="range" id="greenSlider" min="0" max="255" value="${savedConfig.greenValue}" style="width: 100%;">
          </div>
          
          <div style="margin-bottom: 10px;">
            <label style="display: block; margin-bottom: 3px;">è“è‰²: <span id="blueValue">${savedConfig.blueValue}</span></label>
            <input type="range" id="blueSlider" min="0" max="255" value="${savedConfig.blueValue}" style="width: 100%;">
          </div>
          
          <div style="background: #333; padding: 8px; border-radius: 4px; text-align: center;">
            <div id="colorPreview" style="width: 100%; height: 20px; border-radius: 3px; background: rgb(230, 179, 153); margin-bottom: 5px;"></div>
            <span id="colorHex">#e6b399</span>
          </div>
          
          <div style="margin-top: 10px; text-align: center;">
            <button id="resetColorBtn" style="background: #555; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; margin-right: 5px;">é‡ç½®</button>
            <button id="warmToneBtn" style="background: #8B4513; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">æš–è‰²è°ƒ</button>
          </div>
          
          <div style="margin-top: 8px; font-size: 9px; color: #888; text-align: center;">
            é…ç½®è‡ªåŠ¨åŒæ­¥åˆ°Textureç‰ˆæœ¬<br/>
            â˜€ï¸ Lambertå…‰ç…§æè´¨ | MeshLambertMaterial<br/>
            ğŸ¯ face-api.js + 1â‚¬æ»¤æ³¢å™¨ + 3Dæ¨¡å‹è¯†åˆ«
          </div>
        </div>
      `;
      document.body.appendChild(controlPanel);
      
      // ç»‘å®šäº‹ä»¶
      setupColorControlEvents();
    };
    
    // è®¾ç½®é¢œè‰²æ§åˆ¶äº‹ä»¶
    const setupColorControlEvents = () => {
      const colorModeSelect = document.getElementById('colorModeSelect');
      const useAutoColorCheck = document.getElementById('useAutoColorCheck');
      const manualColorControls = document.getElementById('manualColorControls');
      const customColorPicker = document.getElementById('customColorPicker');
      const intensitySlider = document.getElementById('intensitySlider');
      const redSlider = document.getElementById('redSlider');
      const greenSlider = document.getElementById('greenSlider');
      const blueSlider = document.getElementById('blueSlider');
      
      // è®¾ç½®åˆå§‹å€¼
      colorModeSelect.value = colorMode;
      
      // è‡ªåŠ¨ä¿å­˜é…ç½®çš„å‡½æ•°
      const saveCurrentConfig = () => {
        const config = ColorPaletteManager.getCurrentConfig();
        ColorPaletteManager.saveConfig(config);
      };
      
      // é¢œè‰²æ¨¡å¼åˆ‡æ¢
      colorModeSelect.addEventListener('change', (e) => {
        colorMode = e.target.value;
        saveCurrentConfig();
      });
      
      // è‡ªåŠ¨/æ‰‹åŠ¨é¢œè‰²åˆ‡æ¢
      useAutoColorCheck.addEventListener('change', (e) => {
        useAutoColor = e.target.checked;
        manualColorControls.style.display = useAutoColor ? 'none' : 'block';
        saveCurrentConfig();
      });
      
      // æ›´æ–°é¢œè‰²çš„å‡½æ•°
      const updateColor = () => {
        const r = parseInt(redSlider.value);
        const g = parseInt(greenSlider.value);
        const b = parseInt(blueSlider.value);
        
        customColor.setRGB(r / 255, g / 255, b / 255);
        colorIntensity = parseInt(intensitySlider.value) / 100;
        
        // æ›´æ–°æ˜¾ç¤º
        document.getElementById('redValue').textContent = r;
        document.getElementById('greenValue').textContent = g;
        document.getElementById('blueValue').textContent = b;
        document.getElementById('intensityValue').textContent = Math.round(colorIntensity * 100) + '%';
        
        const colorPreview = document.getElementById('colorPreview');
        const colorHex = document.getElementById('colorHex');
        const hexColor = '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        
        colorPreview.style.background = `rgb(${r}, ${g}, ${b})`;
        colorHex.textContent = hexColor;
        customColorPicker.value = hexColor;
        
        // è‡ªåŠ¨ä¿å­˜é…ç½®
        saveCurrentConfig();
      };
      
      // ç»‘å®šæ»‘å—äº‹ä»¶
      intensitySlider.addEventListener('input', updateColor);
      redSlider.addEventListener('input', updateColor);
      greenSlider.addEventListener('input', updateColor);
      blueSlider.addEventListener('input', updateColor);
      
      // é¢œè‰²é€‰æ‹©å™¨äº‹ä»¶
      customColorPicker.addEventListener('change', (e) => {
        const hex = e.target.value;
        const r = parseInt(hex.substr(1, 2), 16);
        const g = parseInt(hex.substr(3, 2), 16);
        const b = parseInt(hex.substr(5, 2), 16);
        
        redSlider.value = r;
        greenSlider.value = g;
        blueSlider.value = b;
        updateColor();
      });
      
      // é¢„è®¾é¢œè‰²æŒ‰é’®äº‹ä»¶
      const resetColorBtn = document.getElementById('resetColorBtn');
      const warmToneBtn = document.getElementById('warmToneBtn');
      
      resetColorBtn.addEventListener('click', () => {
        redSlider.value = 230;
        greenSlider.value = 179;
        blueSlider.value = 153;
        intensitySlider.value = 80;
        updateColor();
      });
      
      warmToneBtn.addEventListener('click', () => {
        redSlider.value = 210;
        greenSlider.value = 150;
        blueSlider.value = 120;
        intensitySlider.value = 75;
        updateColor();
      });
      
      // åˆå§‹åŒ–æ˜¾ç¤º
      updateColor();
      
      // ğŸ”§ 1â‚¬æ»¤æ³¢å™¨å‚æ•°æ§åˆ¶
      const minCutoffSlider = document.getElementById('minCutoffSlider');
      const betaSlider = document.getElementById('betaSlider');
      const minCutoffValue = document.getElementById('minCutoffValue');
      const betaValue = document.getElementById('betaValue');
      
      if (minCutoffSlider && betaSlider) {
        minCutoffSlider.addEventListener('input', (e) => {
          const value = parseFloat(e.target.value);
          minCutoffValue.textContent = value.toFixed(1);
          // æ›´æ–°æ‰€æœ‰æ»¤æ³¢å™¨çš„ minCutoff å‚æ•°
          if (landmarkFilters) {
            landmarkFilters.forEach(filter => {
              filter.x.setMinCutoff(value);
              filter.y.setMinCutoff(value);
            });
          }
        });
        
        betaSlider.addEventListener('input', (e) => {
          const value = parseFloat(e.target.value);
          betaValue.textContent = value.toFixed(2);
          // æ›´æ–°æ‰€æœ‰æ»¤æ³¢å™¨çš„ beta å‚æ•°
          if (landmarkFilters) {
            landmarkFilters.forEach(filter => {
              filter.x.setBeta(value);
              filter.y.setBeta(value);
            });
          }
        });
      }
      
      // ğŸ¯ é¢„è®¾æŒ‰é’®äº‹ä»¶å¤„ç†
      const smoothPreset = document.getElementById('smoothPreset');
      const balancedPreset = document.getElementById('balancedPreset');
      const responsivePreset = document.getElementById('responsivePreset');
      
      const applyPreset = (minCutoff, beta) => {
        if (minCutoffSlider && betaSlider) {
          minCutoffSlider.value = minCutoff;
          betaSlider.value = beta;
          minCutoffValue.textContent = minCutoff.toFixed(1);
          betaValue.textContent = beta.toFixed(2);
          
          if (landmarkFilters) {
            landmarkFilters.forEach(filter => {
              filter.x.setMinCutoff(minCutoff);
              filter.x.setBeta(beta);
              filter.y.setMinCutoff(minCutoff);
              filter.y.setBeta(beta);
            });
          }
        }
      };
      
      if (smoothPreset) {
        smoothPreset.addEventListener('click', () => applyPreset(0.5, 0.02)); // å¼ºå¹³æ»‘ï¼Œä½å“åº”
      }
      if (balancedPreset) {
        balancedPreset.addEventListener('click', () => applyPreset(1.0, 0.04)); // é»˜è®¤å¹³è¡¡
      }
      if (responsivePreset) {
        responsivePreset.addEventListener('click', () => applyPreset(1.5, 0.08)); // å¼±å¹³æ»‘ï¼Œé«˜å“åº”
      }
      

    };
    
    // åˆ›å»ºæ§åˆ¶é¢æ¿
    createColorControlPanel();

    const mindarThree = new MindARThree({
      container: document.querySelector("#container"),
      // æ·»åŠ æ»¤æ³¢å‚æ•°æ¥å‡å°‘æŠ–åŠ¨
      filterMinCF: 0.0001,  // é™ä½æœ€å°æˆªæ­¢é¢‘ç‡ï¼Œå¢åŠ å¹³æ»‘åº¦
      filterBeta: 0.95,      // é™ä½betaå€¼ï¼Œå‡å°‘å“åº”é€Ÿåº¦ä½†å¢åŠ ç¨³å®šæ€§
    });
    const { renderer, scene, camera } = mindarThree;

    // å¼ºåˆ¶WebGLä¸Šä¸‹æ–‡ä½¿ç”¨é«˜æ€§èƒ½GPU
    const gl = renderer.getContext();
    if (gl && gl.getExtension) {
      // å°è¯•å¯ç”¨æ‰€æœ‰å¯èƒ½çš„GPUåŠ é€Ÿæ‰©å±•
      const extensions = [
        'WEBGL_debug_renderer_info',
        'EXT_texture_filter_anisotropic',
        'OES_texture_float',
        'OES_texture_half_float',
        'WEBGL_color_buffer_float'
      ];
      
      extensions.forEach(ext => {
        try {
          gl.getExtension(ext);
        } catch (e) {
          console.log(`æ‰©å±• ${ext} ä¸æ”¯æŒ`);
        }
      });
    }

    // â˜€ï¸ æ·»åŠ å¤šç§å…‰æºï¼šç¯å¢ƒå…‰ + ç›´å°„å…‰ + ç‚¹å…‰æº
    // ç¯å¢ƒå…‰ - æä¾›åŸºç¡€ç…§æ˜ï¼Œäº®åº¦æé«˜1.5å€
    window.ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // æš—ç°è‰²ï¼Œå¼ºåº¦45% (0.3 * 1.5)
    scene.add(window.ambientLight);
    
    // ç›´å°„å…‰ - ä¸»è¦å…‰æºï¼Œæ¨¡æ‹Ÿå¤ªé˜³å…‰
    window.directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // ç™½è‰²ï¼Œå¼ºåº¦80%
    window.directionalLight.position.set(1, 1, 0.5); // å³ä¸Šå‰æ–¹å‘
    window.directionalLight.castShadow = false; // ä¸å¯ç”¨é˜´å½±ï¼ˆæ€§èƒ½è€ƒè™‘ï¼‰
    scene.add(window.directionalLight);
    
    // ç‚¹å…‰æº - æ­£å‰æ–¹è¡¥å…‰
    window.pointLight = new THREE.PointLight(0xffffff, 1.0, 0); // ç™½è‰²ï¼Œå¼ºåº¦60%ï¼Œè¡°å‡è·ç¦»5
    window.pointLight.position.set(0, 0, 2); // æ­£å‰æ–¹ä½ç½®
    scene.add(window.pointLight);

    // è„¸éƒ¨æ¨¡å‹Avatarç±»
    class Avatar {
      constructor() {
        this.gltf = null;
        this.morphTargetMeshes = [];
        this.materials = []; // å­˜å‚¨æ¨¡å‹æè´¨
        this.originalColors = []; // å­˜å‚¨åŸå§‹æè´¨é¢œè‰²
        this.customTexture = null; // è‡ªå®šä¹‰è´´å›¾
      }
      
      async init() {
        console.log('ğŸ¦ å¼€å§‹åŠ è½½è„¸éƒ¨æ¨¡å‹...');
        const url = "./assets/raccoon_head.glb";
        const loader = new GLTFLoader();
        
        // å¦‚æœå¯ç”¨è‡ªå®šä¹‰è´´å›¾ï¼Œå…ˆåŠ è½½è´´å›¾
        if (USE_CUSTOM_TEXTURE) {
          console.log('ğŸ¨ åŠ è½½è‡ªå®šä¹‰è´´å›¾...');
          const textureLoader = new THREE.TextureLoader();
          try {
            this.customTexture = await new Promise((resolve, reject) => {
              textureLoader.load(
                CUSTOM_TEXTURE_PATH,
                (texture) => {
                  texture.flipY = false; // GLBæ¨¡å‹é€šå¸¸éœ€è¦è¿™ä¸ªè®¾ç½®
                  texture.wrapS = THREE.RepeatWrapping;
                  texture.wrapT = THREE.RepeatWrapping;
                  console.log('âœ… è‡ªå®šä¹‰è´´å›¾åŠ è½½æˆåŠŸ');
                  resolve(texture);
                },
                undefined,
                reject
              );
            });
          } catch (error) {
            console.warn('âš ï¸ è‡ªå®šä¹‰è´´å›¾åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹è´´å›¾:', error);
            this.customTexture = null;
          }
        }
        
        const gltf = await new Promise((resolve, reject) => {
          loader.load(url, resolve, undefined, reject);
        });
        
        gltf.scene.traverse((object) => {
          if (object.isBone && !this.root) {
            this.root = object;
          }
          if (!object.isMesh) return;
          
          const mesh = object;
          
          // â˜€ï¸ è½¬æ¢ä¸ºå…‰ç…§æè´¨å¹¶æ”¶é›†æè´¨ä¿¡æ¯
          if (mesh.material) {
            if (Array.isArray(mesh.material)) {
              mesh.material.forEach((mat, index) => {
                // â˜€ï¸ åˆ›å»ºå…‰ç…§æè´¨æ›¿æ¢åŸæœ‰æè´¨
                const litMaterial = new THREE.MeshLambertMaterial({
                  map: USE_CUSTOM_TEXTURE && this.customTexture ? this.customTexture : mat.map,
                  transparent: mat.transparent || false,
                  opacity: mat.opacity || 1.0,
                  color: mat.color ? mat.color.clone() : new THREE.Color(1, 1, 1),
                  alphaTest: mat.alphaTest || 0,
                  side: mat.side || THREE.FrontSide,
                  fog: false,  // ç¦ç”¨é›¾åŒ–æ•ˆæœ
                  toneMapped: false  // ç¦ç”¨è‰²è°ƒæ˜ å°„
                });
                
                // æ›¿æ¢åŸæè´¨
                mesh.material[index] = litMaterial;
                
                if (USE_CUSTOM_TEXTURE && this.customTexture) {
                  console.log(`âœ… å·²åº”ç”¨è‡ªå®šä¹‰è´´å›¾åˆ°å…‰ç…§æè´¨ ${index}`);
                }
                
                this.materials.push(litMaterial);
                this.originalColors.push({
                  color: litMaterial.color.clone(),
                  emissive: new THREE.Color(0, 0, 0)  // å…‰ç…§æè´¨å¯é€‰å‘å…‰è‰²
                });
              });
            } else {
              // â˜€ï¸ åˆ›å»ºå…‰ç…§æè´¨æ›¿æ¢åŸæœ‰æè´¨
              const litMaterial = new THREE.MeshLambertMaterial({
                map: USE_CUSTOM_TEXTURE && this.customTexture ? this.customTexture : mesh.material.map,
                transparent: mesh.material.transparent || false,
                opacity: mesh.material.opacity || 1.0,
                color: mesh.material.color ? mesh.material.color.clone() : new THREE.Color(1, 1, 1),
                alphaTest: mesh.material.alphaTest || 0,
                side: mesh.material.side || THREE.FrontSide,
                fog: false,  // ç¦ç”¨é›¾åŒ–æ•ˆæœ
                toneMapped: false  // ç¦ç”¨è‰²è°ƒæ˜ å°„
              });
              
              // æ›¿æ¢åŸæè´¨
              mesh.material = litMaterial;
              
              if (USE_CUSTOM_TEXTURE && this.customTexture) {
                console.log('âœ… å·²åº”ç”¨è‡ªå®šä¹‰è´´å›¾åˆ°å…‰ç…§ä¸»æè´¨');
              }
              
              this.materials.push(litMaterial);
              this.originalColors.push({
                color: litMaterial.color.clone(),
                emissive: new THREE.Color(0, 0, 0)  // å…‰ç…§æè´¨å¯é€‰å‘å…‰è‰²
              });
            }
          }
          
          if (!mesh.morphTargetDictionary || !mesh.morphTargetInfluences) return;
          this.morphTargetMeshes.push(mesh);
        });
        
        this.gltf = gltf;
        console.log('âœ… è„¸éƒ¨æ¨¡å‹åŠ è½½æˆåŠŸ');
        console.log('â˜€ï¸ å…‰ç…§æ¨¡å¼: Lambertå…‰ç…§ (MeshLambertMaterial)');
        console.log('ğŸ’¡ å…‰æºé…ç½®: ç›´å°„å…‰ + ç¯å¢ƒå…‰ (æš—)');
        console.log(`ğŸ¨ è½¬æ¢æè´¨æ•°é‡: ${this.materials.length}`);
        console.log('ğŸ¯ face-api.js + 1â‚¬æ»¤æ³¢å™¨: è¯†åˆ«3Dæ¨¡å‹é¢éƒ¨ç‰¹å¾');
      }
      
      updateBlendshapes(blendshapes) {
        const categories = blendshapes.categories;
        let coefsMap = new Map();
        
        for (let i = 0; i < categories.length; ++i) {
          coefsMap.set(categories[i].categoryName, categories[i].score);
        }
        
        for (const mesh of this.morphTargetMeshes) {
          if (!mesh.morphTargetDictionary || !mesh.morphTargetInfluences) {
            continue;
          }
          
          for (const [name, value] of coefsMap) {
            if (!Object.keys(mesh.morphTargetDictionary).includes(name)) {
              continue;
            }
            const idx = mesh.morphTargetDictionary[name];
            mesh.morphTargetInfluences[idx] = value;
          }
        }
      }
      
      // å®æ—¶é¢œè‰²è½¬æ¢åŠŸèƒ½ - ç±»ä¼¼DeepFaceLab LTC
      updateSkinColor(faceColor, intensity = 0.7, colorMode = 'multiply') {
        if (!faceColor || this.materials.length === 0) return;
        
        for (let i = 0; i < this.materials.length; i++) {
          const material = this.materials[i];
          const originalColor = this.originalColors[i];
          
          if (material.color && originalColor.color) {
            let blendedColor = new THREE.Color();
            
            if (colorMode === 'multiply') {
              // å¯¹äºé»‘ç™½è´´å›¾ï¼Œä½¿ç”¨ä¹˜æ³•æ··åˆæ›´è‡ªç„¶
              blendedColor.copy(faceColor).multiply(originalColor.color);
            } else if (colorMode === 'overlay') {
              // å åŠ æ¨¡å¼ï¼Œä¿æŒè´´å›¾ç»†èŠ‚
              const base = originalColor.color;
              const overlay = faceColor;
              blendedColor.setRGB(
                base.r < 0.5 ? 2 * base.r * overlay.r : 1 - 2 * (1 - base.r) * (1 - overlay.r),
                base.g < 0.5 ? 2 * base.g * overlay.g : 1 - 2 * (1 - base.g) * (1 - overlay.g),
                base.b < 0.5 ? 2 * base.b * overlay.b : 1 - 2 * (1 - base.b) * (1 - overlay.b)
              );
            } else {
              // çº¿æ€§æ’å€¼æ¨¡å¼
              blendedColor.copy(originalColor.color).lerp(faceColor, intensity);
            }
            
            // åº”ç”¨å¼ºåº¦
            if (colorMode !== 'lerp') {
              blendedColor.lerp(originalColor.color, 1 - intensity);
            }
            
            material.color.copy(blendedColor);
            material.needsUpdate = true;
          }
        }
      }
    }

    // åˆ›å»ºè„¸éƒ¨æ¨¡å‹Avatar
    const avatar = new Avatar();
    await avatar.init();

    // åˆ›å»ºé”šç‚¹å¹¶æ·»åŠ è„¸éƒ¨æ¨¡å‹
    const anchor = mindarThree.addAnchor(1);
    
    // è°ƒæ•´è„¸éƒ¨æ¨¡å‹çš„ç¼©æ”¾ã€ä½ç½®å’Œæ—‹è½¬
    avatar.gltf.scene.scale.set(2.0, 2.0, 2.0);  //
    avatar.gltf.scene.position.set(-0, -0.05, -0.5);     // å‘åç§»åŠ¨2ä¸ªå•ä½ï¼Œè´´è¿‘è„¸éƒ¨

    
    anchor.group.add(avatar.gltf.scene);
    
    // æ·»åŠ é¢å¤–çš„å¹³æ»‘å¤„ç†å˜é‡
    let lastPosition = { x: 0, y: 0, z: 0 };
    let lastRotation = { x: 0, y: 0, z: 0 };
    const smoothingFactor = 0.95; // å¹³æ»‘ç³»æ•°ï¼Œå€¼è¶Šå°è¶Šå¹³æ»‘ä½†å“åº”è¶Šæ…¢
    
    // é¢œè‰²é‡‡æ ·ç›¸å…³å˜é‡
    let colorCanvas = null;
    let colorCtx = null;
    let lastFaceColor = new THREE.Color(0.8, 0.6, 0.5); // é»˜è®¤è‚¤è‰²
    let colorUpdateCounter = 0;
    
    // ğŸ¨ é¢œè‰²æ§åˆ¶è®¾ç½®å·²åœ¨å‰é¢å£°æ˜
    
    // åˆå§‹åŒ–é¢œè‰²é‡‡æ ·Canvas
    const initColorSampling = () => {
      colorCanvas = document.createElement('canvas');
      colorCanvas.width = 64; // å°å°ºå¯¸æé«˜æ€§èƒ½
      colorCanvas.height = 64;
      colorCtx = colorCanvas.getContext('2d');
    };
    
    // ä»è§†é¢‘ä¸­é‡‡æ ·äººè„¸é¢œè‰²
    const sampleFaceColor = (video, estimate) => {
      if (!colorCtx || !estimate || !estimate.metricLandmarks) return lastFaceColor;
      
      try {
        // åªæ¯10å¸§æ›´æ–°ä¸€æ¬¡é¢œè‰²ï¼Œæé«˜æ€§èƒ½
        colorUpdateCounter++;
        if (colorUpdateCounter % 10 !== 0) return lastFaceColor;
        
        // ç»˜åˆ¶è§†é¢‘å¸§åˆ°å°ç”»å¸ƒ
        colorCtx.drawImage(video, 0, 0, colorCanvas.width, colorCanvas.height);
        
        // é‡‡æ ·é¢éƒ¨ä¸­å¿ƒåŒºåŸŸçš„é¢œè‰²
        const centerX = Math.floor(colorCanvas.width * 0.5);
        const centerY = Math.floor(colorCanvas.height * 0.4); // ç¨å¾®åä¸Šï¼Œé¿å¼€å˜´éƒ¨
        const sampleSize = 120; // é‡‡æ ·åŒºåŸŸå¤§å°
        
        let r = 0, g = 0, b = 0, count = 0;
        
        // é‡‡æ ·ä¸­å¿ƒåŒºåŸŸçš„åƒç´ 
        for (let x = centerX - sampleSize; x < centerX + sampleSize; x++) {
          for (let y = centerY - sampleSize; y < centerY + sampleSize; y++) {
            if (x >= 0 && x < colorCanvas.width && y >= 0 && y < colorCanvas.height) {
              const imageData = colorCtx.getImageData(x, y, 1, 1);
              const [pr, pg, pb] = imageData.data;
              
              // æ’é™¤è¿‡æš—æˆ–è¿‡äº®çš„åƒç´ 
              if (pr > 30 && pr < 240 && pg > 30 && pg < 240 && pb > 30 && pb < 240) {
                r += pr;
                g += pg;
                b += pb;
                count++;
              }
            }
          }
        }
        
        if (count > 0) {
          r /= count;
          g /= count;
          b /= count;
          
          // è½¬æ¢ä¸ºThree.jsé¢œè‰²æ ¼å¼
          const newColor = new THREE.Color(r / 255, g / 255, b / 255);
          
          // å¹³æ»‘é¢œè‰²å˜åŒ–
          lastFaceColor.lerp(newColor, 0.1);
        }
        
      } catch (error) {
        console.warn('é¢œè‰²é‡‡æ ·å¤±è´¥:', error);
      }
      
      return lastFaceColor;
    };

    const start = async () => {
      console.log('ğŸš€ å¯åŠ¨ è„¸éƒ¨æ¨¡å‹é¢éƒ¨è·Ÿè¸ªï¼ˆçº¯æœ¬åœ°æºç ï¼‰...');
      await mindarThree.start();
      
      // åˆå§‹åŒ–é¢œè‰²é‡‡æ ·ç³»ç»Ÿ
      initColorSampling();
      
      // ğŸ¯ åˆå§‹åŒ–3Dæ¨¡å‹é¢éƒ¨è¯†åˆ«ç³»ç»Ÿ (å¼‚æ­¥)
      const faceTrackingInitialized = await initFaceTracking();
      
      // ğŸ¯ å¯åŠ¨3Dæ¨¡å‹é¢éƒ¨è¯†åˆ«
      if (faceTrackingInitialized) {
        // è°ƒæ•´é¢éƒ¨ç‚¹ä½ç”»å¸ƒå°ºå¯¸
        adjustFacePointsCanvas();
        
        // åˆå§‹åŒ–1â‚¬æ»¤æ³¢å™¨
        initLandmarkFilters();
        
        // å»¶è¿Ÿå¯åŠ¨é¢éƒ¨è·Ÿè¸ªï¼Œç­‰å¾…3Dæ¨¡å‹æ¸²æŸ“ç¨³å®š
        setTimeout(() => {
          const trackingStarted = startFaceTracking();
          if (trackingStarted) {
            updateFaceTrackingStatus('âœ… 3Dæ¨¡å‹é¢éƒ¨è¯†åˆ«å·²å¯åŠ¨ (1â‚¬æ»¤æ³¢å™¨)');
          } else {
            updateFaceTrackingStatus('âŒ 3Dæ¨¡å‹é¢éƒ¨è¯†åˆ«å¯åŠ¨å¤±è´¥');
          }
        }, 1000); // 1ç§’å»¶è¿Ÿï¼Œç¡®ä¿3Dæ¨¡å‹æ¸²æŸ“ç¨³å®š
        
        // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œé‡æ–°è°ƒæ•´ç¼©æ”¾æ¯”ä¾‹
        window.addEventListener('resize', () => {
          adjustFacePointsCanvas();
        });
      } else {
        updateFaceTrackingStatus('âŒ 3Dæ¨¡å‹é¢éƒ¨è¯†åˆ«åˆå§‹åŒ–å¤±è´¥');
      }
      
      // ğŸ¯ ä¸“æ³¨äº 3D æ¨¡å‹é¢éƒ¨è¯†åˆ«ï¼Œä¸æ˜¾ç¤ºæ‘„åƒæœºç”»é¢
      
      renderer.setAnimationLoop(() => {
        // æ›´æ–°è„¸éƒ¨æ¨¡å‹è¡¨æƒ…
        const estimate = mindarThree.getLatestEstimate();
        if (estimate && estimate.blendshapes) {
          avatar.updateBlendshapes(estimate.blendshapes);
          
          // ğŸ¨ å®æ—¶é¢œè‰²è½¬æ¢ - ç±»ä¼¼DeepFaceLab LTC
          const faceColor = sampleFaceColor(mindarThree.video, estimate);
          
          // æ ¹æ®è®¾ç½®é€‰æ‹©ä½¿ç”¨è‡ªåŠ¨é‡‡æ ·æˆ–æ‰‹åŠ¨é¢œè‰²
          const finalColor = useAutoColor ? faceColor : customColor;
          avatar.updateSkinColor(finalColor, colorIntensity, colorMode);
          
          // æ›´æ–°é¢œè‰²ä¿¡æ¯æ˜¾ç¤º
          const colorInfo = document.getElementById('color-info');
          if (colorInfo && colorUpdateCounter % 30 === 0) { // æ¯30å¸§æ›´æ–°ä¸€æ¬¡æ˜¾ç¤º
            const displayColor = useAutoColor ? faceColor : customColor;
            const rgb = `rgb(${Math.round(displayColor.r * 255)}, ${Math.round(displayColor.g * 255)}, ${Math.round(displayColor.b * 255)})`;
            const colorType = useAutoColor ? 'è‡ªåŠ¨é‡‡æ ·' : 'æ‰‹åŠ¨è®¾ç½®';
            colorInfo.innerHTML = `ğŸ¨ è‚¤è‰² (${colorType}): <span style="color: ${rgb};">â—</span> ${rgb}`;
          }
        }
        
        // å…ˆæ¸²æŸ“3Dåœºæ™¯
        renderer.render(scene, camera);
        
        // ğŸ¯ æ•è·3Dæ¨¡å‹æ¸²æŸ“ç»“æœè¿›è¡Œé¢éƒ¨è¯†åˆ« (face-api.js + 1â‚¬æ»¤æ³¢å™¨)
        if (trackingStarted && modelRenderCanvas) {
          // æ•è·3Dæ¨¡å‹æ¸²æŸ“ç»“æœ
          captureAndAnalyze3DModel(renderer);
          
          // ä½¿ç”¨ face-api.js è¿›è¡Œé¢éƒ¨æ£€æµ‹ - æŒç»­æ£€æµ‹ä½†æ§åˆ¶é¢‘ç‡
          detectionStats.totalAttempts++;
          
          if (detectionStats.totalAttempts % 2 === 0) { // æ¯ä¸¤å¸§æ£€æµ‹ä¸€æ¬¡
            (async () => {
              try {
                const detection = await faceapi.detectSingleFace(modelRenderCanvas, faceDetectorOptions).withFaceLandmarks(true);
                
                if (detection && detection.landmarks) {
                  const landmarks = detection.landmarks.positions;
                  const confidence = detection.detection.score;
                  
                  // ğŸ¯ æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                  detectionStats.successfulDetections++;
                  detectionStats.lastDetectionTime = performance.now();
                  detectionStats.confidenceSum += confidence;
                  detectionStats.avgConfidence = detectionStats.confidenceSum / detectionStats.successfulDetections;
                  
                  // è·å–å½“å‰æ—¶é—´æˆ³ï¼ˆç§’ï¼‰
                  const timestamp = performance.now() / 1000;
                  
                  if (!currentLandmarks || !landmarkFilters) {
                    // é¦–æ¬¡æ£€æµ‹ï¼šç›´æ¥è®¾ç½®å¹¶åˆå§‹åŒ–æ»¤æ³¢å™¨
                    currentLandmarks = landmarks.map(pt => ({ x: pt.x, y: pt.y }));
                    if (!landmarkFilters) {
                      initLandmarkFilters();
                    }
                    console.log(`âœ… é¦–æ¬¡æ£€æµ‹æˆåŠŸï¼Œç½®ä¿¡åº¦: ${confidence.toFixed(3)}`);
                  } else {
                    // ä½¿ç”¨ 1â‚¬ æ»¤æ³¢å™¨å¹³æ»‘æ¯ä¸ªå…³é”®ç‚¹
                    for (let i = 0; i < landmarks.length && i < landmarkFilters.length; i++) {
                      currentLandmarks[i].x = landmarkFilters[i].x.filter(landmarks[i].x, timestamp);
                      currentLandmarks[i].y = landmarkFilters[i].y.filter(landmarks[i].y, timestamp);
                    }
                  }
                  
                  // ğŸ¯ æ¯100æ¬¡æˆåŠŸæ£€æµ‹æ›´æ–°ä¸€æ¬¡çŠ¶æ€æ˜¾ç¤º
                  if (detectionStats.successfulDetections % 100 === 0) {
                    const successRate = ((detectionStats.successfulDetections / detectionStats.totalAttempts) * 100).toFixed(1);
                    updateFaceTrackingStatus(`âœ… è¯†åˆ«æˆåŠŸç‡: ${successRate}% | å¹³å‡ç½®ä¿¡åº¦: ${detectionStats.avgConfidence.toFixed(3)}`);
                  }
                } else {
                  // ğŸ¯ æ£€æµ‹å¤±è´¥ç»Ÿè®¡
                  const timeSinceLastDetection = performance.now() - detectionStats.lastDetectionTime;
                  if (timeSinceLastDetection > 5000) { // 5ç§’æ²¡æœ‰æ£€æµ‹åˆ°
                    const successRate = ((detectionStats.successfulDetections / detectionStats.totalAttempts) * 100).toFixed(1);
                    updateFaceTrackingStatus(`âš ï¸ è¯†åˆ«å›°éš¾ | æˆåŠŸç‡: ${successRate}% | å°è¯•è°ƒæ•´å…‰ç…§æˆ–æ¨¡å‹è§’åº¦`);
                  }
                }
              } catch (error) {
                // è®°å½•æ£€æµ‹é”™è¯¯ï¼Œä½†ä¸åˆ·å±
                if (detectionStats.totalAttempts % 100 === 0) {
                  console.warn('face-api.js æ£€æµ‹å¼‚å¸¸ (æ¯100æ¬¡æŠ¥å‘Šä¸€æ¬¡):', error.message);
                }
              }
            })();
          }
          
          drawFacePoints();
        }
        
        // æ·»åŠ é¢å¤–çš„ä½ç½®å¹³æ»‘å¤„ç†
        if (anchor.group.visible) {
          const currentMatrix = anchor.group.matrix.elements;
          const currentPosition = {
            x: currentMatrix[12],
            y: currentMatrix[13], 
            z: currentMatrix[14]
          };
          
          // çº¿æ€§æ’å€¼å¹³æ»‘ä½ç½®
          lastPosition.x += (currentPosition.x - lastPosition.x) * smoothingFactor;
          lastPosition.y += (currentPosition.y - lastPosition.y) * smoothingFactor;
          lastPosition.z += (currentPosition.z - lastPosition.z) * smoothingFactor;
          
          // åº”ç”¨å¹³æ»‘åçš„ä½ç½®ï¼ˆä»…å¯¹ä½ç§»éƒ¨åˆ†è¿›è¡Œå¹³æ»‘ï¼‰
          anchor.group.matrix.elements[12] = lastPosition.x;
          anchor.group.matrix.elements[13] = lastPosition.y;
          anchor.group.matrix.elements[14] = lastPosition.z;
        }
      });
    }
    
    // é¡µé¢å¸è½½æ—¶ä¿å­˜é…ç½®
    window.addEventListener('beforeunload', () => {
      const config = ColorPaletteManager.getCurrentConfig();
      ColorPaletteManager.saveConfig(config);
    });
    
    start();
  </script>

  <style>
    body {
      margin: 0;
      background: #000;
      font-family: Arial, sans-serif;
    }

    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="container">
  </div>
</body>

</html> 